%%% TODO: mention that admissible does not mean finite model
%%% e.g. ite inside or outside, or custom Bool operators

%%% BEGIN Times font
\usepackage{mathptmx}
\usepackage[scaled=.82]{beramono}
\usepackage[scaled=.86]{helvet}
\DeclareSymbolFont{letters}{OML}{txmi}{m}{it}
%%% END Times font

%\theoremstyle{plain}
%\newtheorem{theorem}{Theorem}%[section]
%\newtheorem{lemma}[theorem]{Lemma}%[section]
%\newtheorem{corollary}[theorem]{Corollary}%[section]

%\theoremstyle{definition}
%\newtheorem{definition}{Definition}%[section]

%\theoremstyle{remark}
%\newtheorem*{proofsketch}{Proof sketch}
%\newtheorem{example}{Example}%[section]

\spnewtheorem*{proofsketch}{Proof sketch}{\itshape}{\rmfamily}

\usepackage{url}
\urldef{\mailsa}\path|firstname.lastname@epfl.ch|
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\newcommand\cvcd{{\cvc}h\xspace}
\newcommand\cvcf{{\cvc}f\xspace}
\newcommand\cvcfe{{\cvc}fh\xspace}
\newcommand\cvcfm{{\cvc}fm\xspace}
\newcommand\ziiib{\ziii}

\renewcommand\models{\mathrel{\vthinspace\vDash}}

%\newcommand{\DDD}{\mathcalx{D}}
\newcommand\DDD{\Delta}

%\newcommand\return{$\mathsf{return}$\xspace}
\newcommand\return{}

%\newcommand\bigtuple[1]{$(${#1}$)$}
\newcommand\bigtuple[1]{$\bigl(${#1}$\bigr)$}

%%% for \mathcalx
\DeclareFontFamily{OT1}{pzc}{}
\DeclareFontShape{OT1}{pzc}{m}{it}{<-> s * [1.10] pzcmi7t}{}
\DeclareMathAlphabet{\mathcalx}{OT1}{pzc}{m}{it}

%%% for correctly sized Greek
\DeclareSymbolFont{letters}{OML}{txmi}{m}{it}

%\newcommand\pneg{\neg}
\newcommand\pnegate{-}
%\newcommand\pnegate{{\sim}}

\newcommand{\con}[1]{\mathsf{#1}}
\let\const=\con

\newcommand\innerkw[1]{\textrm{#1}}
\newcommand\keyw[1]{\texttt{#1}}

\renewcommand\vec[1]{\overline{#1}}

\let\oldcup=\cup
\def\cup{\mathrel{\oldcup}}

\let\oldchi=\chi
\def\chi{{\vthinspace\oldchi}}

\let\oldSigma=\Sigma
\def\Sigma{\mathrm{\oldSigma}}

\let\oldDelta=\Delta
\def\Delta{\mathrm{\oldDelta}}

\def\Chi{\mathrm{X}}

\let\oldneg=\neg
\def\neg{\oldneg\;}

\let\oldvee=\vee
\def\vee{\mathrel{\oldvee}}
\let\oldwedge=\wedge
\def\wedge{\mathrel{\oldwedge}}

\newcommand\win{\bf}
%\newcommand\bench{\ttfamily}

\newcommand\isanun{Nunchaku-Mut\xspace}
\newcommand\ip{IsaPlanner\xspace}
\newcommand\ipm{\ip-Mut\xspace}
\newcommand\leon{Leon\xspace}
\newcommand\leonm{\leon-Mut\xspace}

%\newcommand{\cvc}{\textsc{cvc}{\small 4}\xspace}
%\newcommand{\cvciii}{\textsc{cvc}{\small 3}\xspace}
%\newcommand{\ziii}{\textsc{z}{\small 3}\xspace}

%%% @ANDY, @CESARE: I hope you'll forgive me these. I find the above fonts
%%% distracting. --JB
\newcommand\cvc{CVC4\xspace}
\newcommand\cvciii{CVC3\xspace}
\newcommand\ziii{Z3\xspace}

\newcommand{\teq}{\approx}
\newcommand{\cc}[1]{#1^*}

\newcommand{\terms}{\mathcalx{T}}

%\newcommand{\functerms}{\mathbf{DFT}}
\newcommand{\vars}{\mathbf{V}}
\newcommand{\M}{\mathcalx{M}}
\newcommand{\I}{\mathcalx{I}}
\newcommand{\J}{\mathcalx{J}}
\newcommand{\conv}{\mathcalx{A}}

%\newcommand{\stypes}[1]{#1^\mathrm{s}}
\newcommand{\stypes}[1]{#1^\mathrm{ty}}

\newcommand{\svars}[1]{#1^\mathrm{v}}
\newcommand{\sfuns}[1]{#1^\mathrm{f}}
\newcommand{\sfundefs}[1]{#1^\mathrm{dfn}}
%\newcommand{\sfunndefs}[1]{#1^\mathrm{nf}}
\newcommand{\typeint}{\ty{Int}}

\newcommand{\pnone}{\con{none}}
\newcommand{\ppos}{\con{pos}}
\newcommand{\pneg}{\con{neg}}
%%% @ANDY: as usual, revert if you don't like
% too confusing, too many different meanings for + and -, with below the latter is a theory symbol, a polarity, and a negation of polarities :)
%\newcommand{\pnone}{{\pm}}
%\newcommand{\ppos}{{+}}
%\newcommand{\pneg}{{-}}
\newcommand{\pol}{\con{pol}}

%\newtheorem{remark}{Remark}

\newcommand\ty[1]{\con{#1}}
\newcommand{\Bool}{\ty{Bool}}
\newcommand{\ltrue}{\top}
\newcommand{\lfalse}{\bot}
\newcommand{\lite}{\con{ite}}

%\newcommand\concret{\con{a}}
%\newcommand\concret{\con{c}}
\newcommand\concret{\gamma} %%% from the abstract interpretation literature

\newcommand{\boolop}{\con{b}}
\newcommand{\forallf}[1]{\forall_{\!#1\:}}
\newcommand{\fnull}{\emptyset}
\newcommand{\vecfarg}[1]{\vec{\concret}_{#1}}
\newcommand{\farg}[1]{\concret_{#1}}
\newcommand{\fargx}[2]{\concret_{#1,#2}}
\newcommand{\fargtype}[1]{\alpha_{#1}}

\newcommand{\Sigmalia}{\Sigma_{\mathcalx{LIA}}}
\newcommand{\extendsig}[1]{\mathcalx{E}( #1 )}

\newcommand{\rem}[1]{\textcolor{red}{[#1]}}
\newcommand{\ajr}[1]{\rem{#1 --ajr}}
\newcommand{\jb}[1]{\rem{#1 --jb}}
\newcommand{\ct}[1]{\rem{#1 --ct}}

\newcommand{\negvthinspace}{\kern-0.083333em}
\newcommand{\vthinspace}{\kern+0.083333em}
\newcommand{\vvthinspace}{\kern+0.0416666em}
\newcommand{\typ}[1]{^{\vthinspace #1}}

\newcommand{\definefunreccmd}{\con{define}\text{-}\con{fun}\text{-}\con{rec}}
\newcommand{\definefunsreccmd}{\con{define}\text{-}\con{funs}\text{-}\con{rec}}

\newcommand{\Mo}{{\mathcal{I}}}

%\newcommand{\euf}{\ensuremath{\mathrm{E}}\xspace}
\newcommand{\euf}{\ensuremath{\mathcalx{UF}}\xspace}
%\newcommand{\ari}{\ensuremath{\mathrm{A}}\xspace}
\newcommand{\ari}{\ensuremath{\mathcalx{A}}\xspace}

\newcommand{\absconstraints}{\mathrm{X}}

%\input{scalalistings}
%\input{smtlib2listings}
\usepackage{program}

\def\squareforqed{\hbox{\rlap{$\sqcap$}$\sqcup$}}

\newcommand\xend{{\hfill$\scriptstyle\blacksquare$}}
\renewcommand\qed{{\hfill$\squareforqed$}}

\hyphenation{counter-example counter-examples Isa-belle data-type data-types
  co-data-type co-data-types}

\let\labelitemi=\labelitemii %% CHEAT!
\makeatletter
\ps@myheadings
\makeatother

\begin{document}

\title{Model Finding for Recursive Functions in SMT}
\titlerunning {Model Finding for Recursive Functions in SMT}

\author {Andrew Reynolds\inst{1} \and Jasmin Christian Blanchette\inst{2,3} \and \\ Simon~Cruanes\inst{2} \and Cesare~Tinelli \inst{1}}
\authorrunning {A. Reynolds et al.} % , J. C. Blanchette, S. Cruanes, C. Tinelli}
\institute{
Department of Computer Science, The University of Iowa, USA
\and
Inria Nancy -- Grand Est \& LORIA, Villers-l\`es-Nancy, France
\and
Max-Planck-Institut f\"ur Informatik, Saarbr\"ucken, Germany
%\and
%\'Ecole Polytechnique F\'ed\'erale de Lausanne (EPFL), Switzerland
}

\maketitle

%% The institutions above shouldn't count as footnotes
\setcounter{footnote}{0}

\begin{abstract}
\noindent
SMT solvers have recently been extended with techniques for finding models
in presence of universally quantified formulas in some restricted fragments.
This paper introduces a translation which reduces axioms specifying a large
class of recursive functions, including well-founded (terminating) functions,
to universally quantified formulas for which these
techniques are applicable.
An empirical evaluation confirms that the approach improves 
the performance of existing solvers on benchmarks from three sources. 
The translation is implemented as a preprocessor in the CVC4 solver
and in a new higher-order model finder called Nunchaku.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

Many solvers based on SMT (satisfiability modulo theories) can reason about
quantified formulas using incomplete instantiation-based methods
\cite{MouraBjoerner07,ReynoldsTinelliMoura14}.
These methods work well in the context of proving (i.e., showing
unsatisfiability), but they are of little help for finding models (i.e.,
showing satisfiability). Often, a single universal quantifier in one of the
axioms of a problem is enough to prevent the discovery of models.

In the past few years, techniques have been developed to find models for
quantified formulas in SMT.
Ge and de Moura \cite{GeDeM-CAV-09} introduced a complete instantiation-based
procedure for formulas in the \relax{essentially uninterpreted} fragment.
This fragment is limited to universally quantified formulas where all
%ct occurrences of 
variables occur as direct subterms of uninterpreted
functions---e.g., $\forall x%\typ{\typeint} --- the type is not important, right?
.\;\, \con{f}( x )
\teq \con{g}( x ) + 5$.
% since all
% occurrences of $x$ occur beneath uninterpreted functions $\con{f}$ and
% $\con{g}$.
Other syntactic criteria extend
this fragment slightly, including cases when variables occur as arguments of
arithmetic predicates. Subsequently, Reynolds et al.\
\cite{ReyEtAl-1-RR-13,reynolds-et-al-2013} introduced techniques for finding finite
models for quantified
formulas over uninterpreted types and types having a fixed finite
interpretation. %, such as fixed-width bit vectors and enumerated datatypes.
These techniques can
find a model for a formula such as $\forall x,\, y : \tau.\;\, x \teq
y \vee \allowbreak \neg \con{f}( x ) \teq \con{f}( y )$, where $\tau$ is an uninterpreted type.
% where the uninterpreted type $\tau$ is
% interpreted as a finite set and $\con{f}$ as injective finite map.

Unfortunately, none of these fragments can accommodate the vast majority of
quantified formulas that correspond to recursive function definitions. The
essentially uninterpreted fragment does not allow the argument of a
recursive function to be used inside a complex term on the right-hand side,
whereas the finite model finding techniques %of Reynolds et al.\
are not applicable for functions over infinite domains such as the integers or
algebraic datatypes. A simple example where both approaches fail is
$$\forall x : {\typeint}.\;\,
\con{p}( x ) \teq \lite\bigl( x \leq 0,\allowbreak\;  1,\allowbreak\;
  2 * \con{p}( x - 1 ) \bigr)$$ %.
This state of affairs is unsatisfactory, given the frequency of
recursive definitions in practice and the %impending
addition of a %dedicated
command for introducing them, \texttt{define-fun-rec},
to the SMT-LIB standard \cite{smtlib25}.

%In this paper,
We present a method for translating formulas involving recursive function
definitions into formulas where finite model finding techniques can be applied.
The recursive functions must meet a semantic criterion to be admissible
(Section~\ref{sec:prelim}). This criterion is met by well-founded (terminating)
recursive function definitions. It is not met by inconsistent
definitions such as \,$\forall x : {\typeint}.\;\, \con{f}(x) \teq \con{f}(x) +
1$.

We define a translation for a class of
formulas involving admissible recursive function definitions
(Section~\ref{sec:encoding}). A
recursive definition $\forall x : \tau.\;\, \const{f}(x) \teq \mathit{rhs}$
is translated to
$\forall a :
\fargtype{\tau}.\;\, \const{f}(\farg{\con{f}}(a)) \teq \mathit{rhs}[\farg{\con{f}}(a)/x]$, where
$\fargtype{\tau}$ is an uninterpreted \relax{abstract} type and $\farg{\con{f}} :
\fargtype{\tau} \to \tau$ converts the abstract type to the concrete
type. Additional constraints ensure that the abstract values that are relevant
to the formula's satisfiability
exist. The translation preserves satisfiability and, for admissible definitions,
unsatisfiability, and makes finite model finding possible for problems in this
class.
%\begin{conf} Detailed proofs of correctness are included in a technical
%report \cite{our-report}.\end{conf}

The approach is implemented as a preprocessor in \cvc and in the Nunchaku
model finder (Section~\ref{sec:implementations}).
%As a case study, we employed
%Nunchaku on Isabelle/HOL~\cite{nipkow-et-al-2002} formalizations of
%coinductive lists and binary trees (Section~\ref{sec:case-studies}).
%
We evaluated the two evaluation on benchmarks from
IsaPlanner~\cite{DBLP:conf/itp/JohanssonDB10}, Leon~\cite{blanc2013overview},
and Isabelle/HOL, to demonstrate that this translation improves the
effectiveness of the SMT solvers \cvc and \ziii for finding countermodels to
verification conditions (Section~\ref{sec:evaluation}). Unlike earlier work,
our approach can be combined with off-the-shelf SMT solvers
(Section~\ref{sec:related-work}).

An earlier version of this paper was presented at the SMT 2015 workshop in San
Francisco \cite{reynolds-et-al-2015-smt}. This paper extends the workshop
paper with proof sketches, an expanded implementation section covering
Nunchaku and relevant \cvc optimizations, %the case studies,
and the evaluation on Isabelle benchmarks produced by Nunchaku.

%this option targets users who wish to determine the satisfiability of inputs
%that involving function definitions that are known to be consistent, whereas it
%does not target users who wish to check the consistency of a set of function
%definitions.

\section{Preliminaries}
\label{sec:prelim}

Our setting is a monomorphic (or many-sorted) first-order logic
like the one defined by SMT-LIB \cite{smtlib25}.
A \emph{signature} $\Sigma$ consists of
a set $\stypes{\Sigma}$ of %ct type symbols
first-order types
%
%\ct{What the rationale for using the letter $y$ in $\stypes{\Sigma}$?}
%\jb{y as in t\textbf{y}pe. changed to `ty'}
(or sorts) and a set $\sfuns{\Sigma}$ of function symbols over these types.
We assume that signatures always contain a Boolean type $\Bool$ and constants
$\ltrue, \lfalse : \Bool$ for truth and falsity,
an infix equality predicate ${\teq} : \tau \times \tau \to \Bool$
for each $\tau \in \stypes{\Sigma}$,
standard Boolean connectives ($\neg$, $\wedge$, $\vee$, etc.),
and an \innerkw{if}--\innerkw{then}--\innerkw{else} function symbol
$\lite : \Bool \times \tau \times \tau \rightarrow \tau$
for each $\tau \in \stypes{\Sigma}$.
%
We fix an infinite set $\svars{\Sigma}_\tau$ of \emph{variables of type $\tau$}
for each $\tau \in \stypes{\Sigma}$ and
define $\svars{\Sigma}$ as $\bigcup_{\tau \in \stypes{\Sigma}} \svars{\Sigma}_\tau$.
$\Sigma$-terms are built as usual over functions symbols in $\Sigma$ and variables in $\svars{\Sigma}$.
%
Formulas are terms of type $\Bool$.
We write $t\typ{\tau}$ to denote %ct a metavariable ranging over 
terms of type~$\tau$ and $\terms( t )$ to denote the set of subterms in $t$.
Given a term $u$, we write $u[\vec t/\vec x]$ to denote the result of replacing
all occurrences of $\vec x$ with $\vec t$ in $u$.
\begin{rep}When applied to terms, the symbol $=$ denotes syntactic equality.\end{rep}

%We write $\functerms^\Sigma( t )$ to denote the set of $f$-applications in $t$ such that $\con{f} \in \sfundefs{\Sigma}$.

A \emph{$\Sigma$-interpretation $\I$} %is a mathematical structure that
maps each type $\tau \in \stypes{\Sigma}$ to a nonempty set $\tau^\I$,
the \emph{domain} of~$\tau$ in~$\I,$
each function symbol $\con{f} : \tau_1 \times \cdots \times \tau_n \rightarrow \tau$ in $\sfuns{\Sigma}$
to a total function $\con{f}^\I : \tau_1^\I \times \cdots \times \tau_n^\I \rightarrow \tau^\I$,
and each variable $x:\tau$ of $\svars{\Sigma}$ to an element of $\tau^\I$.
A \emph{theory} is a pair $T = (\Sigma, \Mo)$ where
$\Sigma$ is a signature and $\Mo$ is a class of $\Sigma$-interpretations,
the \emph{models} of $T$, closed under variable reassignment
(i.e., for every $I \in \Mo$, every $\Sigma$-interpretation that differs
from $I$ only on the variables of $\svars \Sigma$ is also in $\Mo$).
A $\Sigma$-formula $\varphi$ is \emph{$T$-satisfiable}
if it is satisfied by some interpretation in $\Mo$\begin{rep};
otherwise, it is \emph{$T$-unsatisfiable}\end{rep}.
A formula $\varphi$ \emph{$T$-entails} $\psi$, written $\varphi \models_T \psi$,
if all interpretations in $\Mo$ that satisfy $\varphi$ also satisfy $\psi$.
Two formulas $\varphi$ and $\psi$ are \emph{$T$-equivalent} 
if each $T$-entails the other.
If $T_1 = (\Sigma_1, \Mo_1)$ is a theory and $\Sigma_2$ is a signature 
with $\sfuns{\Sigma_1} \cap \sfuns{\Sigma_2} = \emptyset$,
the \emph{extension of $T_1$ to $\Sigma_2$} is the theory $T = (\Sigma, \Mo)$ where 
$\sfuns{\Sigma} = \sfuns{\Sigma_1} \cup \sfuns{\Sigma_2}$,
$\stypes{\Sigma} = \stypes{\Sigma_1} \cup \stypes{\Sigma_2}$,
and $\Mo$ is the set of all $\Sigma$-interpretations $\I$
whose $\Sigma_1$-reduct is a model of $T_1$.
We refer to the symbols of $\Sigma_2$ that are not in $\Sigma_1$ as \emph{uninterpreted}.
For the rest of the paper, \relax{we fix a theory $T = (\Sigma, \Mo)$ 
with uninterpreted symbols} constructed as above.

Unconventionally,
we consider \emph{annotated quantified formulas} of the form
$\forallf{\const{f}} \vec x.\; \varphi$, where $\con{f} \in \sfuns{\Sigma}$ is
uninterpreted. Their
semantics is the same as for standard quantified formulas $\forall \vec x.\; \varphi$.
Given $\con{f} : \tau_1 \times \cdots \times \tau_n \rightarrow \tau$,
an annotated
quantified formula $\forallf{\con{f}} \vec x.\; \varphi$ is a \emph{function definition}
(\,\emph{for $\con{f}$}\vthinspace) if $\vec x$ is a tuple of variables
$x_1 : \tau_1$, $\ldots,$ $x_n : \tau_n$
and $\varphi$ is a quantifier-free formula 
$T$-equivalent to $\con{f}( \vec x ) \teq t$ for some term $t$ of type $\tau$.
%\ct{Why can't $\varphi$ be existential instead of just quantifier free?} 
%I don't think it makes much sense to have any quantifiers within function bodies, 
%since they aren't operational, that's why I put quantifier-free. --ajr
%%\jb{Actually, in Isabelle we can have them and we use them sometimes. It certainly
%% makes sense. I can give you real examples if you like.}
We write $\exists
\vec x.\; \varphi$ as an abbreviation for $\neg \forall \vec x.\; \neg \varphi$.

\begin{definition}\rm
A formula $\varphi$ is in \emph{definitional form with respect to}
$\{ \con{f}_1, \ldots, \con{f}_n \} \subseteq \sfuns{\Sigma}$ if it is of the
form
%
%\kern-\abovedisplayskip
%\kern+\abovedisplayshortskip
%
$(\forallf{\con{f}_1} \vec x_1.\; \varphi_1) \wedge \cdots \wedge
(\forallf{\con{f}_n} \vec x_n.\; \varphi_n) \wedge \psi$,
%
where $\con{f}_1, \ldots, \con{f}_n$ are distinct function symbols,
%ct added
$\forallf{\con{f}_i} \vec x_i.\; \varphi_i$ is a function definition
for $i = 1, \ldots, n$,
%
%\ct{I think we need more conditions here on how a symbol $\con{f}_i$ can occur in $\varphi_j$.}
%\jb{do we? I thought that the admissibility criterion below is enough.}
% should be enough, unless I'm missing something? -ajr
and $\psi$ contains no function definitions.
We call $\psi$ the \emph{goal} of $\varphi$.
%\ct{Don't we need additional restrictions on the $\varphi_i$'s here?
%(E.g., they are quantifier-free, or perhaps existential or containing only let binders.)}
% Now fixed above -ajr
\end{definition}

In the signature $\Sigma$, we distinguish a subset $\sfundefs{\Sigma}
\subseteq \sfuns{\Sigma}$ of \emph{defined} uninterpreted function symbols.
We consider $\Sigma$-formulas that are in definitional form with respect to
$\sfundefs{\Sigma}$.

\begin{definition}\rm
Given a set of function definitions 
$\DDD = \{ \forallf{\con{f}_1} \vec x.\; \varphi_1, \ldots, \forallf{\con{f}_n} \vec x.\; \varphi_n \}$, 
a ground formula $\psi$ 
%\ct{I suppose $\psi$ is meant to be ground.} yes --ajr
is \emph{closed under function expansion with respect to $\DDD$} if
\[\psi \models_T \smash{\bigwedge\nolimits_{\,i=1}^{n} \{ \varphi_i[ \vec t / \vec x ] \mid \con{f}_i( \vec t ) \in \terms( \psi ) \}}\]
The set $\DDD$ is \emph{admissible} if for every $T$-satisfiable formula 
$\psi$ closed under function expansion with respect to $\DDD$,
the formula
$\psi \wedge \bigwedge \Delta$ is also $T$-satisfiable.
%\ct{I}
\end{definition}

Admissibility is a semantic criterion that must be satisfied for each function
definition before applying the translation described in
Section~\ref{sec:encoding}. It is useful to connect it to the
standard notion of \emph{well-founded} function definitions, often called
\emph{terminating} definitions in a slight abuse of terminology. In such
definitions, all recursive calls are decreasing with respect to a well-founded
relation, which must be supplied by the user or inferred automatically
using a termination prover. This ensures that the function is uniquely defined
at all points.

First-order logic has no built-in notion of computation or termination. To ensure
that a function specification is well founded, it is sufficient to require that
the function would terminate when seen as a functional program, under \emph{some}
evaluation order. For example, the definition
$\forall x : {\typeint}.\;\, 
\con{p}( x ) \teq \lite\bigl( x \leq 0,\allowbreak\;  1,\allowbreak\;
  2 * \con{p}( x - 1 ) \bigr)$,
where $T$ is integer arithmetic extended with the uninterpreted symbol 
$\con p:\typeint \rightarrow \typeint$, can be shown well founded under a strategy that
evaluates the condition of an $\lite$ before evaluating the relevant branch,
ignoring the other branch. Logically, such dependencies can be captured by
congruence rules. Krauss developed these ideas in the more general context of
higher-order logic \cite[Section 2]{krauss-2009-phd}.

\begin{theorem}\label{thm:adm}
If $\DDD$ is a set of well-founded function definitions for\/
$\sfundefs{\Sigma} = \{\con{f}_1,\ldots,\con{f}_n\}$, then it is admissible.
\end{theorem}
\begin{proofsketch}
Let $\psi$ be a satisfiable formula closed under function expansion with
respect to $\DDD$. We show that $\psi \wedge \bigwedge \Delta$ is also
satisfiable. Let $\I$ be a model of $\psi$, and
let $\I_0$ be the restriction of $\I$ to the function symbols in $\sfuns{\Sigma} -
\sfundefs{\Sigma}$. Because well-founded definitions uniquely characterize
the interpretation of the functions they define, there exists a
$\Sigma$-interpretation $\J$ that extends $\I_0$ such that $\J \models \Delta$.
%
Since $\psi$ is closed under function expansion, it already constrains the
functions in $\sfundefs{\Sigma}$ recursively as far as is
necessary for interpreting $\psi$. Thus, any point $v$ for which
$\const{f}_i^\I(v)$ is needed for interpreting $\psi$ will have its
expected value according to its definition and hence coincide with $\J$.
And since $\psi^\I$ does not depend on the interpretation at the other
points, $\J$ is, like $\I$, a model of $\psi$.
Since $\J \models \Delta$ by assumption, we have $\J \models \psi \wedge
\bigwedge \Delta$ as desired.
%We have
%$\varphi \,\models_T\, \bigwedge\nolimits_{\,i=1}^{n} \{ \varphi_i[ \vec t / \vec x ] \mid \con{f}_i( \vec t ) \in \terms( \varphi ) \}$.
\qed
\end{proofsketch}

% TODO: Say something about admissibility for tail-recursion: Watch out if the
% argument always changes...

Another useful fragment of function definitions is the class of
\emph{productive} corecursive functions. Corecursive functions are functions to
a coalgebraic datatype. These functions can be ill founded, without
their being inconsistent. Productive corecursive functions are functions that
progressively reveal parts of their potentially infinite
output \cite{turner-1995,mcbride-productive}.
For example, given a type of infinite streams constructed by
$\con{scons} : \ty{int} \times \ty{stream} \to \ty{stream}$,
the definition
$\forallf{\const{e}} x.\;\, \const{e}(x) \teq \con{scons}(x,\; \const{e}(x + 1))$
falls within this fragment: Each call to $\const{e}$ produces one
constructor before entering the nested call. Like terminating recursion,
productive corecursion totally specify the functions it defines.
It is even possible to mix recursion and corecursion in the same function
\cite{blanchette-et-al-2015-fouco}. Theorem~\ref{thm:adm} can be extended to
cover such specifications, based on the observation that unfolding
a corecursive definition infinitely computes a unique infinite object.
%We conjecture that a large fragment of mixed recursive--corecursive
%specifications are

\begin{rep}
Beyond totality, an admissible set can contain underspecified functions
such as $\forallf{\con{f}} x : \typeint.\allowbreak\;\, \con{f}( x )
\teq \con{f}( x - 1 )$ or $\forallf{\con{g}} x.\allowbreak\;\, \con{g}( x
) \teq \con{g}( x )$. We conjecture that one can ignore all
tail-recursive calls (i.e., calls that occupy the right-hand side of the
definition, potentially under some $\lite$ branch) when establishing well-foundedness
or productivity, without affecting admissibility.
\end{rep}

%\newcommand\badassex{
% \{\forallf{\con{f}} x : \typeint.\;\, \con{f}( x ) \teq \con{f}( x ),\;\,
% \forallf{\con{g}} x : \typeint.\;\, \lite( \con{f}( x ) \teq 5,\allowbreak\;
%   \con{g}( x ) \teq \con{f}( x ),\allowbreak\;
%   \con{g}( x ) \teq \con{g}( x ) + 1)\}}
\newcommand\badassex{
 \{\forallf{\con{f}} x : \typeint.\;\, \con{f}( x ) \teq \con{f}( x ),\allowbreak\;\,
 \forallf{\con{g}} x : \typeint.\;\, \con{g}( x ) \teq \con{g}( x ) + \nobreak\con{f}( x )\}}

An example of an inadmissible set is
$\{ \forallf{\con{f}} x : \typeint.\;\, \con{f}( x ) \teq \con{f}( x ) + 1 \}$,
where $T$ is integer arithmetic extended to a set of uninterpreted symbols 
$\{\con f, \con g :\typeint \rightarrow \typeint,\, \ldots \}$.
The reason is that the formula $\ltrue$ is (trivially) closed under function expansion with respect to this set,
and there is no model of $T$
satisfying $\con{f}$'s definition. A more subtle example is
\[\badassex\]
While this set has a model where $\con f$ and $\con g$ are interpreted as the
constant function $0$, it is not admissible since %the formula
$\con{f}( 0 ) \teq 1$ is
closed under function expansion \begin{rep}with respect to this set\end{rep}
and yet there exists
no interpretation satisfying both $\con{f}( 0 ) \teq 1$ and $\con{g}$'s
definition.

%Terminating function specifications are always admissible, but also some
%nonterminating
%An admissible function definition need not specify a terminating function, e.g.
%$\{ \forallf{\con{f}} x^\typeint.\;\, \con{f}( x ) \teq \con{f}( x - 1 ) \}$ or even $\{ \forallf{\con{f}} x.\;\, \con{f}( x ) \teq \con{f}( x ) \}$ are admissible.

\section{The Translation}
\label{sec:encoding}

%%% TYPESETTING: approximated, to get centering
\newcommand{\itemx}{\itemindent6.35em\item}

\begin{figure}[t]
\normalsize
\begin{enumerate}
%\begin{framed}
\itemx[\ ]
$\conv_0( t\typ{\tau},\, p )$ $=$
%\\[-.8\baselineskip]
 \begin{itemize}
   \itemx[] $\innerkw{if}$ $\tau = \Bool$ $\mathsf{and}$ $t = \boolop(t_1,\ldots,t_n)$ $\innerkw{then}$
    \begin{itemize}
      \itemx[] $\innerkw{let}$ $( t'_i,\, \chi_i ) = \conv_0( t_i,\, \pol( \boolop,\, i,\, p ) )$ $\mathsf{for}$ $i = 1, \ldots, n$ $\innerkw{in}$%\kern6.35em$\mid$
      \itemx[] $\innerkw{let}$ $\chi = \chi_1 \wedge \cdots \wedge \chi_n$ $\innerkw{in}$
      \itemx[] $\innerkw{if}$ $p = \ppos$ $\innerkw{then}$ \bigtuple{$\boolop(t'_1, \ldots, t'_n) ) \wedge \chi,\, \ltrue$}
      \itemx[] $\innerkw{else}$ $\innerkw{if}$ $p = \pneg$ $\innerkw{then}$ \bigtuple{$\boolop(t'_1, \ldots, t'_n) \vee \neg \chi,\, \ltrue$}
      \itemx[] $\innerkw{else}$ \bigtuple{$\boolop(t'_1, \ldots, t'_n),\, \chi$}
%\\[-.8\baselineskip]
    \end{itemize}
  \itemx[] $\innerkw{else}$ $\innerkw{if}$ $t = \forallf{\con{f}} \vec x.\;\, u$ $\innerkw{then}$
    \begin{itemize}
      \itemx[] $\innerkw{let}$ $( u',\, \chi ) = \conv_0( u,\, p )$ $\innerkw{in}$ \bigtuple{$\forall a : \fargtype{\con{f}}.\; u' [ \vecfarg{\con{f}}( a ) / \vec x ],\, \ltrue$}
%\\[-.8\baselineskip]
    \end{itemize}
  \itemx[] $\innerkw{else}$ $\innerkw{if}$ $t = \forall \vec x.\;\, u$ $\innerkw{then}$
    \begin{itemize}
      \itemx[] $\innerkw{let}$ $( u',\, \chi ) = \conv_0( u,\, p )$ $\innerkw{in}$ \bigtuple{$\forall \vec x.\; u',\, \forall \vec x.\; \chi$}
%\\[-.8\baselineskip]
    \end{itemize}
   \itemx[] $\innerkw{else}$
   \begin{itemize}
     \itemx[] \return \bigtuple{$t,\; \bigwedge\, \{ \exists a : \fargtype{\con{f}}.\; \vecfarg{\con{f}}( a ) \teq \vec s \mid \con{f}( \vec s ) \in \terms( t ),\, \con{f} \in \sfundefs{\Sigma} \}$}
%\\[-.8\baselineskip]
   \end{itemize}
 \end{itemize}
\end{enumerate}
\begin{enumerate}
%\begin{framed}
\itemx[\ ]
$\conv( \varphi )$ $=$ $\innerkw{let}$ $( \varphi',\, \chi ) = \conv_0( \varphi,\, \ppos )$ $\innerkw{in}$ $\varphi'$
\\[-1.5\baselineskip] %% TYPESETTING
\end{enumerate}
\caption{\,Definition of translation $\conv$}
\label{fig:A}
\end{figure}

For the rest of the section, let $\varphi$ be a $\Sigma$-formula
in definitional form with respect to $\sfundefs{\Sigma}$
whose definitions are admissible.
%We may translate $\varphi$ into a equisatisfiable formula $\phi'$ for which known model-finding procedures~\cite{GeDeM-CAV-09, ReyEtAl-1-RR-13} are applicable.
We present a method that constructs an extended signature
$\extendsig{ \Sigma }$ and an $\extendsig{ \Sigma }$-formula $\varphi'$ such that
$\varphi'$ is $T$-satisfiable if and only if $\varphi$ is $T$-satisfiable---i.e.,
$\varphi$ and $\varphi'$ are \emph{equisatisfiable} (\emph{in $T$}).
The idea behind this translation
is to use an uninterpreted type to abstract the set of
\emph{relevant} tuples for each defined function $\con{f}$ and restrict the
quantification of $\con{f}$'s definition to a variable of this
type. 
Informally, the relevant tuples $\vec t$ of a function $\con{f}$ are the
ones for which the interpretation of $\con{f}( \vec t )$ is relevant to the
satisfiability of $\varphi$.
More precisely,
%suppose our signature $\Sigma$ contains a set of defined function symbols $\sfundefs{\Sigma} \subseteq \sfuns{\Sigma}$.
for each $\con{f} : \tau_1 \times \cdots \times \tau_n \rightarrow \tau \in \sfundefs{\Sigma}$,
the extended signature $\extendsig{\Sigma}$ contains
%\begin{itemize}
%\item
an uninterpreted \emph{abstract type} $\fargtype{\con{f}}$ and
%\item
$n$ uninterpreted \emph{concretization functions} $\fargx{\con{f}}{1} : \fargtype{\con{f}} \rightarrow \tau_1$, \ldots, $\fargx{\con{f}}{n} : \fargtype{\con{f}} \rightarrow \tau_n$.
%\end{itemize}
%The interpretation of uninterpreted type $\fargtype{\con{f}}$ will denote the elements (tuples) on which the function $\con{f}$ is applied.
%The role of the uninterpreted functions $\farg{\con{f}}^1$, $\ldots$, $\farg{\con{f}}^n$ will be discussed more in the following.

The translation $\conv$ defined in Figure~\ref{fig:A} translates the $\Sigma$-formula
$\varphi$ into the $\extendsig{\Sigma}$-formula $\varphi'$. It relies
on the auxiliary function $\conv_0$, which takes two arguments:\ the term $t$
to translate and a \relax{polarity}~$p$ for $t$, which is either $\ppos$, $\pneg$, or
$\pnone$. 
\vthinspace$\conv_0$ returns a pair $( t'\negvthinspace,\, \chi )$, where $t'$ is a term of
the same type as $t$ and $\chi$ is an $\extendsig{\Sigma}$-formula.
%an additional constraint.
%This constraint is needed if the polarity is $\pnone$; otherwise, it is encoded
%directly in $t'$ and $\chi$ is simply $\ltrue$.
%In the auxiliary function $\conv_0$, the function $\pol(
%\boolop, i, p )$ returns the polarity of the $i$\vvthinspace{th} argument of an
%application of~$\boolop$ having polarity $p$ if $\boolop$ is an interpreted
%predicate or $\pnone$ otherwise.


%The role of $D$ is to ensure that
%the (restricted) function definition for $\con{f}$ includes certain tuples in
%its domain, which we explain more in the following.

The translation alters the formula $\varphi$ in two ways. First, it restricts the
quantification on function definitions for $\con{f}$ to the corresponding
uninterpreted type $\fargtype{\con{f}}$, inserting applications of the concretization functions $\fargx{\con{f}}{i}$ as needed. 
Second, it augments $\varphi$ with additional constraints of the form
$\exists a :\nobreak \fargtype{\con{f}}.\;\, \vecfarg{\con{f}}( a ) \teq \vec s$,
where $\vecfarg{\con{f}}( a ) \teq \vec s$ abbreviates the formula
$\bigwedge_{i=1}^n\, \fargx{\con{f}}{i}(a) \teq s_i$
with $\vec s = (s_1,\ldots,s_n)$.
These existential %%% for typesetting
constraints
ensure that the restricted definition for $\con{f}$ covers all relevant tuples
of terms, namely those occurring in applications of $\con{f}$ 
that are relevant to the satisfiability of $\varphi$. The constraints are
generated as deep in the formula as possible, based on our knowledge of the
polarities of logical connectives, to allow models in which the domains
interpreting the $\fargtype{\con{f}}$ types are as small as possible.

If $t$ is an application of a predicate symbol $\boolop$, including the
operators ${\oldneg}$, ${\wedge}$, ${\vee}$, ${\teq}$, and ${\lite}$,
$\conv_0$ calls itself recursively on the arguments $t_i$ and polarity $\pol(
\boolop, i, p )$, with $\pol$ d\rlap{efined as}
\[\pol( \boolop, i, p ) =
\begin{cases}
p & \text{if either $\boolop \in \{{\wedge}, {\vee}\}$ or $\boolop = \lite$ and $i \in \{2, 3\}$} \\[-\jot]
\pnegate p & \text{if $\boolop = {\neg}$} \\[-\jot]
\pnone & \text{otherwise}
\end{cases}\]
where $\pnegate p$ is $\pneg$ if $p$ is $\ppos$, $\ppos$
if $p$ is $\pneg$, and $\pnone$ if $p$ is $\pnone$.
The term $t$ is then reconstructed as $\boolop(t_1',\ldots,t_n')$ 
where each $t_i'$ is the result of the recursive call with argument~$t_i$. 
If the polarity $p$ associated with $t$ is $\ppos$, 
$\conv_0$ conjunctively adds to $\boolop(t_1',\ldots,t_n')$ the constraint $\chi$ derived from
the subterms and returns $\top$ as the constraint.
Dually, if $p$ is $\pneg$, it adds a
disjunction with the negated constraint, to achieve the same overall effect.
%ct  as in the positive case. 
It $p$ is $\pnone$, the constraint $\chi$ is
returned to the caller.

If $t$ is a function definition, % of a function in $\sfundefs{\Sigma}$,
$\conv_0$ constructs a quantified formula over a single variable
$a$ of type $\fargtype{\con{f}}$ and replaces all occurrences of $\vec x$ in
the body of that formula with $\vecfarg{\con{f}}( a )$. 
(Since function definitions are top-level conjuncts, %by case analysis on the return values of $\conv$,
$\chi$ must be $\ltrue$ and can be ignored.)
%
If $t$ is an unannotated quantified formula, $\conv_0$ calls itself
on the body with the same polarity; a quantifier is prefixed to the
quantified formula and constraint returned by the recursive call.
Otherwise, $t$ is either an application of an uninterpreted predicate symbol or a term
of a type other than $\Bool$. Then, the returned constraint is a conjunction of
formulas of the form $\exists a : {\fargtype{\con{f}}}.\;\, \vecfarg{\con{f}}(
a ) \teq \vec s$ for each subterm $\con{f}( \vec s )$ of~$t$ such that $\con{f}
\in \sfundefs{\Sigma}$. Such constraints, when asserted positively, ensure that
some element in the abstract domain $\fargtype{\con f}$ is the preimage of
the argument tuple $\vec s$. % under $\vecfarg{\con{f}}$.

%We demonstrate this translation with an example.

\begin{example}
\label{ex:translation}
Let $T$ be linear integer arithmetic
with the uninterpreted symbols  $\{ \const{c} : { \typeint },\allowbreak\> \con{s} : { \typeint \rightarrow \typeint } \}$.
Let $\varphi$ be the $\Sigma$-formula
\begin{equation} \label{eq:ex-before}
\forallf{\con{s}} x : {\typeint}.\;\, \lite\bigl( x \leq 0,\; \con{s}(x) \teq 0,\;
  \con{s}( x ) \teq x + \con{s}( x - 1 ) \bigr) \wedge \con{s}( \con{c} ) > 100
\end{equation}
%
The definition of $\const{s}$ specifies that it returns the sum of all
positive integers up to $x$. The formula $\varphi$ is in definitional form with
respect to $\sfundefs{\Sigma}$ 
%\jb{correct? It said $\Sigma_u$, which was definitely wrong} 
and states that the sum of all
positive numbers up to some constant $\const{c}$ is greater than $100$. It is
satisfiable with a model that interprets $\const{c}$ as $14$ or more.
Due to the universal quantifier,
current SMT techniques
are unable to find
a model for $\varphi$. The signature $\extendsig{\Sigma}$ extends $\Sigma$ with the type
$\fargtype{\con{s}}$ and the uninterpreted function symbol $\farg{\con{s}} : \fargtype{\con{s}}
\rightarrow \typeint$. The result of $\conv( \varphi )$, after simplification, 
is the $\extendsig{\Sigma}$-formula
%
\begin{equation} \label{eq:ex-after}
\!\begin{aligned}[c]
  & \phantom{{\wedge}\; }\bigl(
      \forall a : \fargtype{\con{s}}.\; \lite\bigl(
        \!\begin{aligned}[t]
         &  \farg{\con{s}}( a ) \leq 0,\;
          \con{s}(\farg{\con{s}}( a )) \teq 0,\;
\\[-\jot]
  & \con{s}(\farg{\con{s}}( a )) \teq \farg{\con{s}}( a ) + \con{s}( \farg{\con{s}}( a )-1 )
    \wedge \exists b : {\fargtype{\con{s}}}.\;\, \farg{\con{s}}( b ) \teq \farg{\con{s}}( a )-1 \bigr) \bigr)
\end{aligned}
\\[-\jot]
 & {\wedge}\; \con{s}( \con{c} ) > 100 \wedge \exists a : {\fargtype{\con{s}}}.\;\, \farg{\con{s}}( a ) \teq \con{c}
\end{aligned}
\end{equation}
%
The universal quantifier in formula~(\ref{eq:ex-after}) ranges over an uninterpreted
type $\fargtype{\con{s}}$, making it amenable to the finite model finding
techniques by Reynolds et al.\ \cite{ReyEtAl-1-RR-13,reynolds-et-al-2013},
implemented in \cvc, which search for a finite interpretation for $\fargtype{\con{s}}$. 
Furthermore, since all occurrences of the quantified variable~$a$ are 
beneath applications of the uninterpreted function $\farg{\con{s}}$, 
the formula is in the essentially uninterpreted fragment,
for which Ge and de Moura \cite{GeDeM-CAV-09} provide 
a complete instantiation procedure, implemented in \ziii. 
As expected,
%%% Are we sure?  
% Yes, I'm planning to post the 2 versions of the benchmark on the evaluation page (when we add it) --ajr
% Yes, but how can you be sure that Z3 will run forever? Your benchmarks surely have a timeout! --jb
\cvc and \ziii run indefinitely on formula~(\ref{eq:ex-before}), 
whereas they produce a model for~(\ref{eq:ex-after}) 
within 100 milliseconds.\xend
\end{example}

\newcommand\badlambda{\lambda x : \typeint.\allowbreak\;\, \lite( x \teq 0,\allowbreak\; 0,\allowbreak\;
  \lite( x \teq 1,\allowbreak\; 1,\allowbreak\;
    \lite( x \teq 2,\allowbreak\; 3,\allowbreak\;
      \lite(\ldots,\allowbreak\; \lite( x \teq 13,\allowbreak\, 91,\allowbreak\, 105 )\negvthinspace \ldots ))))}

Note that the translation $\conv$ results in formulas whose models
(i.e., satisfying interpretations) are generally different from those of $\varphi$.
%\ct{"Preserves models" means that it does not drop models, not that it adds models.}
One model $\I$ for formula~(\ref{eq:ex-after}) in the above example interprets
$\fargtype{\con{s}}$ as a finite set $\{ u_0, \ldots, u_{14} \}$,
$\farg{\con{s}}$ as a finite map $u_i \mapsto i$ for $i = 0, \ldots, 14$,
$\con{c}$ as $14$,
and $\con{s}$ as the almost constant function
%
%\begin{equation} \label{eq:approx-interp}
\[\badlambda\]
%\end{equation}
%
In other words, $\const{s}$ is interpreted as a function mapping $x$ to the sum
of all positive integers up to $x$ when $0 \leq x \leq 13$, and $105$
otherwise.
The $\Sigma$-reduct of $\I$ is not a model of the original formula~(\ref{eq:ex-before}),
since $\I$ 
%ct wrongly in what sense?
%wrongly 
interprets $\con{s}( n )$ as $105$ when $n < 0$ or $n > 14$.

However, under the assumption that the function definitions in
$\sfundefs{\Sigma}$ are admissible, %we claim that
$\conv(\varphi)$ is equisatisfiable with $\varphi$ for any input $\varphi$.
%\footnote{
%ct moved in a footnote to avoid breaking the flow
%jb killed altogether
%For the previous example, the intuition is that the
%interpretation of a term such as $\con{s}( -1 )$ is not
%relevant to the satisfiability of formula~(\ref{eq:ex-before}). 
%}
%ct removed because obvious
%Thus, a ``satisfiable'' or ``unsatisfiable'' response from an SMT solver on input $\conv(
%\varphi )$ implies the existence or nonexistence of a model for
%$\varphi$. 
Moreover, the models of $\conv( \varphi )$ contain
pertinent information about the models of $\varphi$. For example, the model
$\I$ for formula~(\ref{eq:ex-after}) given above interprets $\con{c}$ as $14$
and $\con{s}(n)$ as $\sum_{i=1}^n i$ for $0 \le n \le 14$,
and there exists a model of formula~(\ref{eq:ex-before}) that also interprets
$\con{c}$ and $\con{s}(n)$ in the same way (for $0 \le n \le 14$).
In general, for every model of $\conv( \varphi )$,
there exists a model of $\varphi$ that
coincides with it on its interpretation of all
function symbols in $\sfuns{\Sigma} - \sfundefs{\Sigma}$.
%($\{\con{s} \}$ in the example
%\ct{This is not right. To start, the set difference should contain all the arithmetic symbols here. Moreover, isn't $\con s$ in $\sfundefs{\Sigma}$?})
Furthermore, the model of $\conv( \varphi )$ will
also give correct information for the defined functions at all points belonging
to the domains of the corresponding abstract types $\fargtype{\con{f}}$.
This can sometimes help users debug their specifications.

%%% @ANDY: I don't get the following comment --jb
%   @JASMIN : The point of this comment is that the user is not interested in the SMT solver inferring any new information regarding the interpretation of s,
%             since s is a "defined" function, the user already has an intended interpretation in their head of what s is (here, the sum of positive integers between 0...x).
%             Thus, it isn't a big deal that the SMT solver "approximates" the interpretation of s during a check, since we already know what s is.
%From a practical point of view, this is not an
%issue, because $s$ is the very function that was explicitly defined by the
%user, and hence already has an intended interpretation.

%%% @ANDY: Now I understand. My experience with Nitpick is that users sometimes
%%% want to see the partial information available about defined functions. I've
%%% added a couple of sentences above to that effect.

%In the following,
We sketch the correctness of translation~$\conv$.
For a set of ground literals~$L$, 
we write $\absconstraints( L )$ to denote the set of constraints that
force the concretization functions to have the necessary elements in their
range for determining the satisfiability of $L$ with respect to the function
definitions in the translation.
Formally,
\[\absconstraints( L ) \vthinspace=\vthinspace \smash{\{ \exists a : {\fargtype{\con{f}}}.\;\, \vecfarg{\con{f}}( a ) \teq \nobreak \vec t
\nobreak\mid\allowbreak \con{f}( \vec t ) \in \terms( L ),\: \con{f} \in \sfundefs{\Sigma}
\}}\]
The following lemma states the central invariant behind the translation $\conv$.

\begin{lemma}\label{lem:conv}
Let $\psi$ be a formula not containing function definitions,
and let $\I$ be an $\extendsig{\Sigma}$-interpretation.
Then $\I$ satisfies $\conv( \psi )$ if and only if
$\I$ satisfies $L \cup \absconstraints( L )$, where $L$ is a set of ground $\Sigma$-literals that entail $\psi$.
%There exists a set of ground $\Sigma$-literals $L$ such that $L$ entails $\varphi$, 
%and $\I$ satisfies $L \cup \absconstraints( L )$.
\end{lemma}
\begin{proofsketch}
By definition of $\conv$ and case analysis on the return values of $\conv_0$.
\qed
\end{proofsketch}

\begin{corollary}\label{cor:conv}
If $\psi$ is a formula not containing function definitions, then $\conv( \psi )$ entails $\psi$.
\end{corollary}

\begin{theorem}\label{thm:equi}
If $\varphi$ is a\/ $\Sigma$-formula in definitional form with respect to\/
$\sfundefs{\Sigma}$
and the set of function definitions\/ $\DDD$ corresponding to\/
$\sfundefs{\Sigma}$ is admissible, then\/ $\varphi$ and\/ $\conv( \varphi )$ are
equisatisfiable in $T$.
\end{theorem}
\begin{proofsketch}
First, we show that if $\varphi$ is satisfied by an
$\Sigma$-interpretation $\I$, then $\conv( \varphi )$ is satisfied by an $\extendsig{\Sigma}$-interpretation $\J$.
Let $\J$ be the $\extendsig{\Sigma}$-interpretation that interprets all types $\tau \in \stypes{\Sigma}$ as~$\tau^\I$,
all functions $\con{f} \in \sfuns{\Sigma}$ as $\con{f}^\I$,
and for each function $\con{f} : \tau_1 \times \cdots \times \tau_n \rightarrow \tau$ in $\sfundefs{\Sigma}$,
interprets $\fargtype{\con{f}}$ as $\tau_1^\I \times \cdots \times \tau_n^\I$
and each $\fargx{\con{f}}{i}$ as the $i$\vvthinspace{th} projection on such tuples for $i = 1, \ldots, n$.
Since $\J$ satisfies $\varphi$, it satisfies a set of ground literals $L$ that entail $\varphi$.
Furthermore, $\J$ satisfies \relax{every} constraint of the form $\exists a : {\fargtype{\con{f}}}.\;\, \vecfarg{\con{f}}( a ) \teq \vec t$,
since by our construction of $\J$ there exists a value $v \in {\fargtype{\con{f}}}^\J$ such that $v = \vec t^\J$.
%By case analysis it follows that $\conv_0$ maintains the invariant that
%if $\conv_0( t\typ{\Bool}, \ppos )$ returns $( {t'}, \chi )$,
%then $\I$ satisfies $t$ if and only if $\J$ satisfies $t'$.
Thus, $\J$ satisfies $L \cup \absconstraints( L )$, and by Lemma~\ref{lem:conv}
we conclude $\J$ satisfies $\conv( \varphi )$.

Second, we show that if $\conv( \varphi )$ is satisfied by a
$\extendsig{\Sigma}$-interpretation $\J$, then $\varphi$ is satisfied by a
$\Sigma$-interpretation $\I$. Since $\varphi$ is in definitional form with
respect to the functions defined by $\DDD$, it must be of the form
$\DDD \wedge \varphi_0$. 
%We argue that $\J$ satisfies a $\Sigma$-formula
%$\varphi'$ that is closed under function expansion with respect to $\DDD$, and
%where $\varphi'$ entails $\varphi_0$.
%To construct $\varphi'$, 
First, we define a sequence of $\Sigma$-literals sets $L_0 \subseteq L_1 \subseteq \cdots$
such that $\J$ satisfies $L_i \cup \absconstraints( L_i )$ for $i = 0, 1, \ldots\vthinspace$.
Since $\J$ satisfies $\conv( \varphi_0 )$,
by Lemma~\ref{lem:conv}, 
$\J$ satisfies a set of literals $L \cup \absconstraints( L )$ where $L$ is a set of $\Sigma$-literals that entail $\varphi_0$.
Let $L_0 = L$.
For each $i \geq 0$,
let $\psi_i$ be the formula $\bigwedge\, \{ \conv( \varphi_{\con{f}}[ \vec t / \vec x ] ) \mid \con{f}( \vec t ) \in \terms( L_i ),\: \con{f} \in \sfundefs{\Sigma} \}$,
where $\forallf{\con{f}} \vec x.\; \varphi_{\con{f}} \in \DDD$.
Since $\J$ satisfies $\conv( \forallf{\con{f}} \vec x.\; \varphi_{\con{f}} )$ and $\absconstraints( L_i )$,
we know that $\J$ also satisfies $\psi_i$.
Thus by Lemma~\ref{lem:conv},
$\J$ satisfies a set of literals $L \cup \absconstraints( L )$ where $L$ is a set of $\Sigma$-literals that entail $\psi_i$.
Let $L_{i+1} = L_0 \cup L$.
Let $L_\infty$ be the limit of this sequence (i.e., $\ell \in L_\infty$ if and only if
$\ell \in L_i$ for some $i$),
and let $\psi$ be the $\Sigma$-formula $\bigwedge L_\infty$.
To show that $\psi$ is closed under function expansion with respect to $\DDD$,
we first note that by construction $\psi$ entails $\psi_\infty$.
For any function symbol~$\con{f}$ and terms~$\vec t$, since $\varphi_{\con{f}}[ \vec t / \vec x ]$ does not contain function definitions,
by Corollary~\ref{cor:conv},
$\conv( \varphi_{\con{f}}[ \vec t / \vec x ] )$ entails $\varphi_{\con{f}}[ \vec t / \vec x ]$.
Thus, $\psi$ entails $\{ \varphi_{\con{f}}[ \vec t / \vec x ] \mid \con{f}( \vec t ) \in \terms( \psi ), \con{f} \in \sfundefs{\Sigma} \}$,
meaning that $\psi$ is closed under function expansion with respect to $\DDD$.
Furthermore, $\psi$ entails $\varphi_0$ since $L_0 \subseteq L_\infty$.
Since $\psi$ is a $T$-satisfiable formula that is closed under function expansion\begin{rep} with respect to $\DDD$\end{rep} and $\DDD$ is admissible, 
by definition there exists a $\Sigma$-interpretation $\I$ satisfying $\psi \wedge \DDD$, which entails $\DDD \wedge \varphi_0$,
i.e., $\varphi$.
\qed
\end{proofsketch}

The intuition of the above proof is as follows.
First, $\conv( \varphi )$ cannot be unsatisfiable when $\varphi$ is satisfiable
since any $\Sigma$-interpretation that satisfies $\varphi$ can be extended in a straightforward way to 
an $\extendsig{\Sigma}$-interpretation that satisfies $\conv( \varphi )$, by
interpreting the abstract types in the same way as the cartesian products they
abstract, thereby satisfying all existential constraints introduced by $\conv$.
Conversely, if a model is found for $\conv( \varphi )$,
existential constraints
%the constraints $\exists a : \fargtype{\con{f}}.\;\, \vecfarg{\con{f}}( a ) \teq \vec t$
introduced by $\conv$ ensure that this model also satisfies
a $\Sigma$-formula that is closed under function expansion and
that entails the goal of $\varphi$.
This implies the existence of a model for $\varphi$,
assuming $\DDD$ is admissible.
%For clarity, we demonstrate the consequences of this theorem by means of an example.

\begin{conf}
We give an intuition of the above theorem in the context of an example.
For a set of ground $\Sigma$-literals $L$, let $\absconstraints( L )$ be the set
$\{ \exists a : {\fargtype{\con{f}}}.\;\, \vecfarg{\con{f}}( a ) \teq \vec s
\mid \con{f}( \vec s ) \in \terms( L ),\: \con{f} \in \sfundefs{\Sigma}
\}$.
\end{conf}

\begin{example}
Let us revisit the formulas in Example~\ref{ex:translation}. 
%ct rephrased in more direct terms.
%This formula is unsatisfiable only if
%formula~(\ref{eq:ex-before}) is unsatisfiable, since $\fargtype{\con{s}}$ can be
%interpreted as the integers and $\farg{\con{s}}$ as the identity
%function. 
If the original formula~(\ref{eq:ex-before}) is $T$-satisfiable, the translated
formula~(\ref{eq:ex-after}) is clearly also $T$-satisfiable since $\fargtype{\con{s}}$ can be
interpreted as the integers and $\farg{\con{s}}$ as the identity function. 
%
Conversely, we claim that~(\ref{eq:ex-after}) is $T$-satisfiable
only if~(\ref{eq:ex-before}) is $T$-satisfiable, noting that the set
$\{ \forallf{\con{s}} x.\;\, \varphi_\con{s} \}$ is admissible,
where $\varphi_\con{s}$ is the formula $\lite\bigl( x \leq 0,\allowbreak\; \con{s}(x) \teq\nobreak 0,\allowbreak\; \con{s}( x ) \teq x + \con{s}( x-1 ) \bigr)$.
%\ct{
%You cannot possibly mean "if and only if" in the two sentences above.
%Once I show that (1) is unsat iff (2) is unsat, I do not need to argue that
%(1) is sat iff (2) is sat. That is immediate.
%}
% You're right, changed both to "only if" --ajr
%As stated
%in the proof of Theorem~\ref{thm:equi}, the reason is that any model of
%formula~(\ref{eq:ex-after}) must satisfy a formula that is closed under
%function expansion, hence implying that formula~(\ref{eq:ex-before}) has a
%model.
%The rightmost conjunct $\exists a : {\fargtype{\con{s}}}. (\farg{\con{s}}( a ) \teq \con{c})$ 
%ensures that if $\con{s}( \con{c} ) > 100$ is a constraint that 
%formula~(\ref{eq:ex-after}) satisfying $\con{s}( \con{c} ) > 100$ also
%satisfies $\varphi_{\con{s}}[\con{c}/x]$. 
%The nested existential
%$\exists b.\;\, \farg{\con{s}}( b ) \teq \farg{\con{s}}( a )-1$ ensures that
%a similar constraint is enforced recursively: when $\varphi_{\con{s}}[t/x]$ is used in part to evaluate $\con{s}( \con{c} )$,
%any model of $\varphi_{\con{s}}[t/x]$ must also satisfy $\varphi_{\con{s}}[t-1/x]$ when $t > 0$. 
Clearly, any interpretation $\I$ satisfying formula~(\ref{eq:ex-after}) satisfies 
$L_0 \cup \absconstraints( L_0 )$,
where $L_0 = \{ \con{s}( \con{c} ) > 100 \}$
and $\absconstraints( L_0 )$ consists of the single constraint
$\exists a : {\fargtype{\con{s}}}.\;\, \farg{\con{s}}( a ) \teq \con{c}$.
%The latter ensures that $\I$ satisfies a formula that entails both $\con{s}( \con{c} ) > 100$ and $\varphi_{\con{s}}[\con{c}/x]$.
Since $\I$ also satisfies both the translated function definition for $\con{s}$
(the first conjunct of~(\ref{eq:ex-after})) and $\absconstraints( L_0
)$, it must also satis\rlap{fy}
\[
\lite\bigl( \con{c} \leq 0,\; 
            \con{s}(\con{c}) \teq 0,\;
            \con{s}(\con{c}) \teq \con{c} + \con{s}( \con{c}-1 )
            \wedge \exists b : {\fargtype{\con{s}}}.\;\, \farg{\con{s}}( b ) \teq \con{c}-1 \bigr)
\]
The existential constraint in the above formula
ensures that whenever $\I$ satisfies the set $L_1 = L_0 \cup \{ \neg \con{c} \leq 0,\; \con{s}(\con{c}) \teq \con{c} + \con{s}( \con{c}-1 ) \}$,
$\I$ satisfies $\absconstraints( L_1 )$ as well.
Hence, by repeated application of this reasoning, it follows that
a model of formula~(\ref{eq:ex-after}) that interprets $\con{c}$ as~$n$ must also satisfy~$\psi$:
%
\[\begin{aligned}[t]
\con{s}( \con{c} ) > 100 %\displaystyle
& {} \wedge \relax{\bigwedge\nolimits_{\vthinspace i=0}^{\!\smash{n-1}}} \bigl( \neg (\con{c}-i \leq 0) \wedge \con{s}( \con{c}-i ) \teq \con{c}-i + \con{s}( \con{c}-i-1 ) \bigr) \\[-\jot]
& {} \wedge \con{c}-n \leq 0 \wedge \con{s}( \con{c}-n ) \teq 0
\end{aligned}\]
%
This formula is closed under function expansion
since it entails $\varphi_\con{s}[(\con{c}-i)/x]$ for $i = 0, \ldots, n$,
and it contains only $\con{s}$ applications corresponding to $\con{s}( \con{c}-i )$ for $i = 0, \ldots, n$.
Since $\{\forallf{\con{s}} x.\;\, \varphi_\con{s}\}$ is admissible,
there exists a $\Sigma$-interpretation satisfying $\psi \wedge \forallf{\con{s}} x.\;\, \varphi_\con{s}$,
which entails formula~(\ref{eq:ex-before}).\xend
\end{example}

\section{Implementations}
\label{sec:implementations}

We have implemented the translation $\conv$ in two separate systems, 
as a preprocessor in \cvc (version~1.5 prerelease)
and in the \cvc-based higher-order model finder Nunchaku.
This section describes how the translation is implemented in these systems,
as well as optimizations used by \cvc for finding models of translated
problems. % for the translated benchmarks.

%The translation $\conv$ significantly improves the effectiveness of current SMT
%techniques for finding models of formulas involving recursive
%function definitions.
%We have implemented it in the development version of \cvc %~\cite{ReyEtAl-1-RR-13}
%(version~1.5 prerelease).

\subsection{CVC4}
\label{ssec:cvc4}

% When invoked with a specific
% command-line option, the solver assumes that functions introduced using the
% \texttt{define-fun-rec} command are admissible and translates them accordingly.

In \cvc, function definitions $\forallf{\con{f}} \vec x.\; \varphi$ can be written using the $\definefunreccmd$ command
from SMT-LIB 2.5~\cite{smtlib25}.
Formula~(\ref{eq:ex-before}) from Example~\ref{ex:translation}
can be specified as %follows:
%
\begin{quote}
%\small -- no small, unless you convince me that these mixtures of font sizes
% are aesthetic and serve a purpose --jb
\verb|(define-fun-rec s ((x Int)) Int (ite (<= x 0) 0 (+ x (s (- x 1)))))|\kern-200mm \\
\verb|(declare-fun c () Int)| \\
\verb|(assert (> (s c) 100))| \\
\verb|(check-sat)|
\end{quote}
%
When reading this input,
\begin{rep}%
\cvc adds the annotated quantified formula
$$\forallf{\con{s}} x.\;\, \con{s}( x ) \teq \lite\bigl( x \leq 0,\; 0,\; \con{s}( x-1 )\bigr)$$
to its list of assertions,
which after rewriting becomes
$$\forallf{\con{s}} x.\;\, \lite\bigl( x \leq 0,\; \con{s}( x ) \teq 0,\; \con{s}( x ) \teq \con{s}( x-1 ) \bigr)$$
\end{rep}%
\begin{conf}%
\cvc adds
$\forallf{\con{s}} x.\;\, \con{s}( x ) \teq \lite\bigl( x \leq 0,\; 0,\; \con{s}( x-1 )\bigr)$
to its list of assertions,
which after rewriting becomes
$\forallf{\con{s}} x.\;\, \lite\bigl( x \leq 0,\; \con{s}( x ) \teq 0,\; \con{s}( x ) \teq \con{s}( x-1 ) \bigr)$. \end{conf}%
By specifying the command-line option \texttt{-}\texttt{-fmf-fun}, users
can enable \cvc's finite model finding mode for recursive functions.
In this mode, \cvc will replace its list of known
assertions based on the $\conv$ translation before checking for satisfiability.
%If the functions provided in the input are admissible,
%then a ``satisfiable" response from the solver implies that a model exists for the original formula.
Accordingly, the solver will output the approximation of the interpretation it
used for recursive function definitions. 
For the example above, it outputs a %partial
model of~$\con{s}$ where only
the values of $\con{s}(x)$ for $x = 0,\ldots,14$ are correctly given:
\begin{quote}
%\small
\begin{verbatim}
(model
  (define-fun s (($x1 Int)) Int 
    (ite (= $x1 14) 105 (ite (= $x1 13) 91 (ite (= $x1 12) 78 
      (ite (= $x1 11) 66 (ite (= $x1 10) 55 (ite (= $x1 4) 10 
        (ite (= $x1 9) 45 (ite (= $x1 8) 36 (ite (= $x1 7) 28 
          (ite (= $x1 6) 21 (ite (= $x1 3) 6 (ite (= $x1 5) 15 
            (ite (= $x1 2) 3 (ite (= $x1 1) 1 0)))))))))))))))
  (define-fun c () Int 14))
\end{verbatim}
\end{quote}

With the \texttt{-}\texttt{-fmf-fun} option enabled, \cvc assumes that
functions introduced using \texttt{define-\allowbreak fun-\allowbreak rec} are admissible.
Admissibility must be discharged separately by the user---e.g., using a
syntactic criterion or a termination prover.
If some function definitions are not admissible, \cvc may answer \emph{sat} for
an unsatisfiable problem. 
\begin{rep}
Indeed, if we add the inconsistent definition
%
\begin{quote}
%\small
\begin{verbatim}
(define-fun-rec h ((x Int)) Int (+ (h x) x))
\end{verbatim}
\end{quote}
%
to the above problem and run \cvc with the \texttt{-}\texttt{-fmf-fun} option,
it wrongly answers \emph{sat}.
\end{rep}

\cvc implements a few optimizations designed to help finding finite models of
$\conv(\varphi)$.
Like other systems,
the finite model finding capability of \cvc incrementally fixes bounds on the cardinalities of uninterpreted types
and increases these bounds until it encounters a model.
When multiple types are present, it uses a fairness scheme that
bounds the sum of cardinalities of all uninterpreted types~\cite{reynolds2013finite}.
For example, if a signature has two uninterpreted types $\tau_1$ and $\tau_2$,
it will first search for models where 
$\left\vert\tau_1\right\vert + \left\vert\tau_2\right\vert$ is at most $2$,
then $3$, $4$, and so on.
To accelerate the search for models,
we implemented an optimization based on statically inferring \emph{monotonic} types.
A monotonic type is one in which models can always be extended with additional
elements of that type \cite{blanchette-krauss-2011,claessen-et-al-2011}.
%%% I find this part more confusing than helping, since we use monotonicity to merge
%%% sorts (or at least their cardinality bounds), whereas Paradox and iProver use
%%% it to separate sorts! Our use of monotonicity is more related to Nitpick's. --jb
%%%
% korovin-2013
%Inference of monotonic types has been show in previous work~
%to be an important component of finite model finding systems.
Types $\fargtype{\con{f}}$ introduced by our translation $\conv$ are monotonic,
because $\teq$ is never used directly on such types \cite{claessen-et-al-2011}.
%
%The finite model finding capability of
\cvc takes advantage of this by fixing the bounds for all 
monotonic types simultaneously.
That is, if $\tau_1$ and $\tau_2$ are inferred monotonic (whether they are
present in the original problem or introduced by our translation),
the solver fixes the bound for \relax{both} types to be $1$, then $2$, and so on.
This scheme allows the solver greater flexibility compared with the default scheme,
and comes with no loss of generality with respect to models,
since monotonic types can always be extended to have equal cardinalities.

By default, \cvc uses techniques to minimize the number of literals it
considers when constructing propositional satisfying assignments for
formulas~\cite{relevancy2007}. However, we have found such techniques degrade
performance for finite model finding on problems having recursive functions
that are defined by cases. For this reason, we disable the techniques for
problems produced from our translation.

%%% \ajr{More?} -- Probably no space. Otherwise, you could mention zero sorts. --jb

%Usually not interested in showing logical consistency, there
%exist other tools that check e.g. termination.
%Thus, want SMT solver to check satisfiability the assumption that recursive
%functions are consistent (where this needs to be defined precisely).

\subsection{Nunchaku}
\label{ssec:nunchaku}

Nunchaku is a new higher-order model finder designed to be integrated with
several proof assistants. The first version, 0.1, was released in January 2016
with support for (co)algebraic datatypes, (co)recursive functions and
(co)inductive predicates. Support for higher-order functions is planned for
the next release. We have developed a preliminary Isabelle frontend and are
planning further frontends for Coq, the TLA\textsuperscript{+} Proof System,
and possibly other proof assistants.

Nunchaku is the spiritual successor to Nitpick for
Isabelle/HOL~\cite{blanchette-nipkow-2010}, but is developed as a standalone
OCaml program, with its own input language. Whereas Nitpick generates a
succession of problems where cardinalities of finite types grow at each step,
Nunchaku translates its input to one first-order logic program that targets
the finite model finding fragment of CVC4, including
(co)algebraic datatypes \cite{reynolds-blanchette-2015-codata}.
Using CVC4 also allows Nunchaku to provide efficient arithmetic
reasoning and to detect unsatisfiability in addition to satisfiability.
% and makes
% equality reasoning straightforward.

The input syntax was inspired by that other systems based on higher-order
logic (e.g., Isabelle/HOL) and by functional programming languages (e.g.,
OCaml). The following simple problem gives a taste of the syntax:
%
\begin{quote}
\verb$data nat := Zero | Suc nat.$ \\[2\jot]
\verb$pred even : nat -> prop :=$ \\
\verb$  even Zero;$ \\
\verb$  forall n. odd n => even (Suc n)$ \\
\verb$and odd : nat -> prop :=$ \\
\verb$  forall n. even n => odd (Suc n).$ \\[2\jot]
\verb$val m : nat.$ \\
\verb$goal even m && ~ (m = Zero).$
\end{quote}
%
The problem defines a datatype (\texttt{nat}) and two mutually recursive
inductive predicates (\texttt{even} and \texttt{odd}), it declares a constant
\texttt{m}, and specifies a goal to satisfy (``$m$ is even and nonzero'').
Nunchaku quickly finds the following partial model:
%
\begin{quote}
\verb$val m := Suc (Suc Zero).$ \\
\verb$val odd := fun x. if x = Suc Zero then true else ?__.$ \\
\verb$val even := fun x. if x = Suc (Suc Zero) || x = Zero then true$ \\
\verb$                   else ?__.$
\end{quote}
%
The partial model gives sufficient information to the user to evaluate the
goal: ``2 is even if 1 is odd, 1 is odd if 0 is even, and 0 is even.''

Nunchaku parses and types the input problem before applying a sequence
of translations, each reducing the distance to the target fragment.
In our example, the predicates
\verb!even! and \verb!odd! are \emph{polarized} (specialized into a pair of
predicates such that one is used in positive positions and the other in
negative positions),
$m$ is skolemized into a fresh constants,
then translated into admissible recursive functions,
before another pass applies the encoding described in this paper.
If a model is found, it is translated back to the input language,
with \verb$?__$ placeholders indicating unknown values.

Conceptually, the sequence of transformation is a \relax{two-way pipeline}
built by composing pairs $(\textsf{encode},\vthinspace \textsf{decode})$ of
transformations. For each such pair, \textsf{encode} transforms a problem over
a signature $\Sigma$ in a logic~$\mathcal{L}$ to a problem over a signature
$\Sigma'$ in a logic~$\mathcal{L}'$, and \textsf{decode} translates a model
in~$\mathcal{L}'$ over $\Sigma'$ into a model in~$\mathcal{L}$ over $\Sigma$,
in the spirit of institution theory \cite{goguen-burstall-1992}. The
pipeline currently consists of the following phases:

\begin{description}
%{{{
  \item[Type inference] infers types and checks definitions;
  \item[Type skolemization]
    replaces $\exists \alpha.\; \varphi[\alpha]$
      with $\varphi[\tau]$, where $\tau$ is a fresh type;
  \item[Monomorphization]
    specializes polymorphic definitions on their type arguments and removes
    unused definitions;
  \item[Elimination of equations]
    translates multiple-equation definitions of recursive functions into
      a single nested pattern matching;
  \item[Polarization]
    specializes predicates into a version used in positive positions
      and a version used in negative positions;
  \item[Unrolling]
    adds a decreasing argument to possibly ill-founded predicates to make
    them well founded;
  \item[Skolemization]
    introduces Skolem symbols for term variables;
  \item[Elimination of (co)inductive predicates]
    recasts a multiple-clause (co)inductive predicate specification
      into a recursive equation;
  \item[Recursion elimination]
    performs the encoding from Section~\ref{sec:encoding};
  \item[Elimination of pattern matching]
    rewrites pattern-matching expressions using datatype
    discriminators and selectors;
  \item[CVC4 invocation] runs CVC4 to obtain a model.
%}}}
\end{description}

% \subsection{Decoding of Recursive Functions}
% 
% Nunchaku is designed for finding counter-models to formulas a user thinks
% are theorems. Decoding models from CVC4 to hide any trace of the successive
% encodings is therefore vital for readability. Each step
% of the pipeline only has to concern itself with removing its changes to
% the signature and logic; our encoding of recursive functions is no exceptions.
% 
% TODO explain how:
% - domains of proj. functions are computed
% - domains of original function is deduced
% - decision tree for original function is built
% - note how junk is removed in step 3 (but undefined "..." as last case)
% 
% \subsection{Support for Higher-Order Functions}
% 
% TODO:
% - currying with explicit application symbol --> function arguments are now
%   just constants
% - apply encoding on application symbol
% - gotcha: one function can be used with several arities.
% 
% - optim: specialization (similar to monomorphization)

%\section{Case Studies}
%\label{sec:case-studies}
%
%We show Nunchaku in action on two small Isabelle formalizations:\ coinductive
%lists and a binary data structure called AA trees. These two examples were
%used before to demonstrate Nitpick \cite{}.
%
%\subsection{Coinductive Lists}
%
%TODO: Adapt!
%
%\newcommand\List[1]{[#1]}
%\newcommand\Nil{\List{\vthinspace}}
%\newcommand\bool{\mathit{bool}}
%
%The Isabelle codatatype $\alpha\>\mathit{llist}$ of lazy lists is generated by the
%constructors $\const{LNil} : {\alpha\>\mathit{llist}}$ and $\const{LCons} : {\alpha\to
%\alpha\>\mathit{llist} \to \alpha\>\mathit{llist}}$. It is of particular interest to countermodel finding
%because many %basic
%properties of finite lists do not carry over to infinite
%lists, often in baffling ways. To illustrate this, we conjecture that
%appending $\textit{ys}$ to $\textit{xs}$ yields $\textit{xs}$ iff
%$\textit{ys}$ is $\const{LNil}$:
%\[\textit{xs} \mathbin{@} \textit{ys} = \textit{xs} \,\longleftrightarrow\,
%  \textit{ys} = \const{LNil}\]
%The operator $\mathbin{@}$ is defined by primitive corecursion by the equation
%\[\textit{xs} \mathbin{@} \textit{ys} =
%  (\innerkw{case}~\textit{xs}~\innerkw{of}~\const{LNil} \Rightarrow \textit{ys}
%  \mid \const{LCons}\;x\;\textit{xs}' \Rightarrow \const{LCons}\;x\;(\textit{xs}' \mathbin{@} \textit{ys}))\]
%Nunchaku immediately
%finds the countermodel $\textit{xs} = \textit{ys} =
%\List{0, 0, \ldots}$, in which a cardinality of 1 is sufficient for
%$\alpha$ and $\alpha\>\mathit{llist}$, and the bisimilarity predicate $\sim$ is unrolled only
%once. Indeed, appending $\List{0, 0, \ldots} \not= \Nil{}$ to $\List{0, 0, \ldots}$ leaves
%$\List{0, 0, \ldots}$ unchanged. Many other counterexamples are possible---for example,
%$\textit{xs} = \List{0, 0, \ldots}$ and $\textit{ys} = \List{1}$---but Nitpick
%tends to reuse the objects that are part of a subterm-closed substructure to
%keep cardinalities low. Although very simple, the counterexample is beyond
%Quickcheck's and Refute's reach, since they do not support codatatypes.
%
%The next example requires the following lexicographic order predicate:
%%
%\begin{quote}
%$\keyw{coinductive}~\vthinspace\smash{{\preceq}\typ{\mathit{nat}\>\mathit{llist}\to\mathit{nat}\>\mathit{llist}\to\bool}}~\keyw{where}$ \\
%$\const{LNil} \preceq \textit{xs}$ \\
%$x \le y \,\Longrightarrow\, \const{LCons}~x~\textit{xs} \preceq \const{LCons}~y~\textit{ys}$ \\
%$\textit{xs} \preceq \textit{ys} \,\Longrightarrow\, \const{LCons}~x~\textit{xs} \preceq \const{LCons}~x~\textit{ys}$
%\end{quote}
%%
%The intention is to define a linear order on lazy lists of
%natural numbers, and hence the following properties should hold:
%%
%\begin{align*}
%\textsc{Refl}{:}\kern.75em
%  & \textit{xs} \preceq \textit{xs}
%& \textsc{Antisym}{:}\kern.75em
%  & \textit{xs} \preceq \textit{ys} \mathrel{\land} \textit{ys} \preceq \textit{xs} \longrightarrow \textit{xs} = \textit{ys} \\
%\textsc{Linear}{:}\kern.75em
%  & \textit{xs} \preceq \textit{ys} \mathrel{\lor} \textit{ys} \preceq \textit{xs}
%& \textsc{Trans}{:}\kern.75em
%  & \textit{xs} \preceq \textit{ys} \mathrel{\land} \textit{ys} \preceq \textit{zs} \longrightarrow \textit{xs} \preceq \textit{zs}%.
%\end{align*}
%%
%However, Nitpick finds a counterexample for \textsc{Antisym}: $\textit{xs} = \List{1,
%1}$ and $\textit{ys} = \List{1}$. On closer inspection, the assumption $x \leq y$ of
%the second introduction rule for $\preceq$ should have been $x < y$; otherwise,
%any two lists \textit{xs}, \textit{ys} with the same head satisfy
%$\textit{xs} \preceq \textit{ys}$. Once we repair the specification, no more
%counterexamples are found for the four properties up to cardinality 6
%for $\textit{nat}$ and $\mathit{nat}\>\mathit{llist}$ within the time limit of 30~seconds.
%%This is a strong indication that the properties hold.
%Andreas Lochbihler used Isabelle
%to prove all four properties \cite{lochbihler-2010-coinduction}.
%
%We could continue like this and sketch a full-blown theory of lazy lists. Once the
%definitions and main theorems %are in place and
%have been thoroughly tested using
%Nitpick, we could start working on the proofs. Developing theories this way
%can save a lot of time, because faulty theorems and definitions are discovered
%early. %in the process.
%
%\subsection{AA Trees}

\section{Evaluation}
\label{sec:evaluation}

In this section, we evaluate both the overall impact of the translation
introduced in Section~\ref{sec:encoding} and the performance of individual SMT
techniques.
%
We gathered 602 benchmarks from three sources, which we will refer to as
\ip, \leon, and \isanun:
\begin{itemize}
\item
\ip{} consists of the 79 benchmarks from the IsaPlanner
suite~\cite{DBLP:conf/itp/JohanssonDB10} that do not contain higher-order
functions. These benchmarks have been used recently as challenge problems for a
variety of inductive theorem provers. They heavily involve
recursive functions and are limited to a theory of algebraic datatypes
with a signature that contains uninterpreted function symbols over these datatypes. 

\smallskip

\item
\leon{} consists of 166
benchmarks from the Leon repository,\footnote{%Available at
\url{https://github.com/epfl-lara/leon/}} which were constructed from
verification conditions about simple Scala programs. These benchmarks also
heavily involve recursively defined functions over algebraic datatypes, 
but cover a wide variety of additional theories, including bit vectors, arrays, and
both linear and nonlinear arithmetic.

\smallskip

\item
\isanun{} consists of 357 benchmarks originating from Isabelle/HOL. They
involve (co)recursively defined functions over (co)algebraic datatypes and
uninterpreted functions but no other theories. They were obtained by mutation
of negated Isabelle theorems, as was done for evaluating
Nitpick~\cite{blanchette-nipkow-2010}. Benchmarks created by mutation have a
high likelihood of having small, easy-to-find models.
\end{itemize}

The \ip{} and \leon{} benchmarks are expressed in SMT-LIB 2.5 and are in
definitional form with respect to a set of well-founded functions.
The Leon tool was used to generate SMT-LIB files.
A majority of these benchmarks are unsatisfiable.
For each of the 245 benchmarks,
we considered up to three randomly selected
mutated forms of its goal $\psi$. In particular, we considered unique
formulas that are obtained as a result of exchanging a subterm of $\psi$ at
one position with another of the same type at another position.
In total, we considered 213 mutated forms of
theorems from \ip and 427 mutated forms of theorems from \leon. We will
call these sets \ipm and \leonm, respectively. Each of these benchmarks exists
in two versions:\ without and with the $\conv$~translation. Problems with
$\conv$ were produced by running \cvc's preprocessor % (Section~\ref{ssec:cvc4})
on each benchmark.

For \isanun, the Isabelle Nunchaku frontend was used to generate thousands of
Nunchaku problems from Isabelle/HOL theory files involving lists, trees, and
other functional data structures. Nunchaku was then used to generate SMT-LIB
files, again in two versions:\ without and with the $\conv$~translation.
Problems requiring higher-order logic were discarted, since Nunchaku does not
yet support them, leaving 357 problems.

% Our entire benchmark set consists of 1242 benchmarks (640 mutants plus the
% original 602). 

%Each of the 1242 benchmarks were generated in SMT lib version 2.5 format~\cite{smtlib25}. %ajr : although these don't require 2.5 features


%We additionally considered these 1242 benchmarks both before and after the translation~$\conv$.
%For example, \ip contains 79 original benchmarks $\varphi$ and 79 translated
%benchmarks $\conv(\varphi)$.
%For the \isanun, \ajr{describe generation of smt2 benchmarks with encoding}.

Among SMT solvers, we considered \ziii~\cite{de-moura-bjoerner-2008} and
\cvc~\cite{barrett-et-al-2011}.
\ziii runs heuristic methods for quantifier instantiation~\cite{MouraBjoerner07}
as well as methods for finding models for quantified formulas~\cite{GeDeM-CAV-09}.
For \cvc, we considered four configurations, referred
to as \cvcd, \cvcf, \cvcfe, and \cvcfm.
The configuration \cvcd runs heuristic 
and conflict-based techniques for quantifier instantiation~\cite{ReynoldsTinelliMoura14},
but does not include techniques for finding models.
The other configurations run the finite model
finding procedure due to Reynolds et al.\ \cite{ReyEtAl-1-RR-13,reynolds-et-al-2013}.
The configuration \cvcfe additionally incorporates heuristic quantifier instantiation as described in Section 2.3 of~\cite{reynolds-et-al-2013},
and \cvcfm incorporates the fairness scheme for monotonic types as described in Section~\ref{ssec:cvc4}.

\begin{figure}[t]
%ct I would not use the normal size in figure makes them look out of proportion
%\normalsize
%\small
\small
\centering
\begin{tabular}{l@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\,\,}}
  & \multicolumn{2}{c@{\kern1.5em}}{\phantom{0}\ziiib}     & \multicolumn{2}{c@{\kern1.5em}}{\phantom{0}\cvcd}     
  & \multicolumn{2}{c@{\kern1.5em}}{\phantom{0}\cvcf}      & \multicolumn{2}{c@{\kern1.5em}}{\cvcfe} 
  & \multicolumn{2}{c@{\,\,}}{\cvcfm}
\\%[-1pt]
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
\\
\midrule

\ip & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0
\\
\ipm & 0 & 43 & 0 & 0 & 0 & {\win 161} & 0 & {\win 161} & 0 & {\win 161}
\\
\leon  & 8 & 30 & 6 & 6 & 6 & {\win 54} & 6 & 53 & 6 & {\win 54}
\\
\leonm & 6 & 61 & 0 & 0 & 2 & 180 & 2 & {\win 181} & 2 & {\win 181}
\\
\isanun  & 0 & 14 & 0 & 0 & 0 & 155 & 0 & {\win 156} & 0 & 155
\\[\jot]
Total & 14 & 148 & 6 & 6 & 8 & 550 & 8 & {\win 551} & 8 & {\win 551}
\end{tabular}
\caption{\,Number of \emph{sat} responses on benchmarks without and with $\conv$ translation}
\label{fig:sat}
\end{figure}

\begin{figure}[t]
\small
%\normalsize
%\small
\centering
\begin{tabular}{l@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\,\,}}
  & \multicolumn{2}{c@{\kern1.5em}}{\phantom{0}\ziiib}     & \multicolumn{2}{c@{\kern1.5em}}{\phantom{0}\cvcd}     
  & \multicolumn{2}{c@{\kern1.5em}}{\phantom{0}\cvcf}      & \multicolumn{2}{c@{\kern1.5em}}{\cvcfe} 
  & \multicolumn{2}{c@{\,\,}}{\cvcfm}
\\%[-1pt]
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
\\
\midrule
\ip & 14 & {\win 15} & {\win 15} & {\win 15} & 1 & {\win 15} & {\win 15} & {\win 15} & 1 & {\win 15}
\\
\ipm & 54 & 55 & {\win 56} & {\win 56} & 13 & 55 & {\win 56} & 55 & 13 & 55
\\
\leon & 48 & 52 & {\win 58} & 52 & 12 & 53 & {\win 58} & 50 & 12 & 53
\\
\leonm & 94 & 107 & 106 & 107 & 39 & {\win 108} & 106 & {\win 108} & 39 & {\win 108}
\\
\isanun & {\win 41} & 40 & 28 & 34 & 26 & 39 & 26 & 39 & 26 & 39
\\[\jot]
Total & 251 & 269 & 263 & 264 & 91 & {\win 270} & 261 & 267 & 91 & {\win 270}
\end{tabular}
\caption{\,Number of \emph{unsat} responses on benchmarks without and with $\conv$ translation}
\label{fig:unsat}
\end{figure}

The results are summarized in Figures \ref{fig:sat} and \ref{fig:unsat}.
Bold indicates the maximum of a row.
The benchmarks and more detailed results are available online.%
\footnote{\url{http://lara.epfl.ch/~reynolds/IJCAR2016-recfun/}}
The figures are divided into benchmarks triggering \emph{unsat} and \emph{sat}
responses and further into benchmarks before and after the translation $\conv$.
The raw evaluation data reveals no cases in which a solver answered
\emph{unsat} on a benchmark $\varphi$ and \emph{sat} on its
corresponding benchmark $\conv( \varphi )$, or vice versa.
This is consistent with our expectations and Theorem~\ref{thm:equi}, 
since these benchmarks contain only well-founded function definitions.

Figure~\ref{fig:sat} shows that for untranslated benchmarks (the ``$\varphi$''
columns), the number of \emph{sat} responses is very low across all
configurations. This confirms the shortcomings of existing SMT techniques for
finding models for benchmarks containing recursively defined functions.
%
The translation $\conv$ (the ``$\conv(\varphi)$'' columns) has a major
impact. \cvcf finds 550 of the 1242 benchmarks to be satisfiable,
including 6~benchmarks in the nonmutated \leon benchmark set. 
The two optimizations for finite model finding in \cvc (configurations \cvcfe and \cvcfm) 
led to a net gain of one~satisfiable benchmark each with respect to \cvcf.
The performance of \ziiib for countermodels also improved dramatically, as it
finds 134 more benchmarks to be satisfiable, including 5 that are not solved by \cvcf.
%
We conclude that the translation $\conv$ enables SMT
solvers to find countermodels for conjectures involving recursively defined
functions whose definitions are admissible.

Moreover,
the translation $\conv$ helps all configurations for \emph{unsat} responses as well.
\ziii solves a total of 269 with the translation, whereas it solves only 251 without it.
Surprisingly,
the configuration \cvcf, which is not tailored for handling unsatisfiable benchmarks,
solves 270 \emph{unsat} benchmarks overall, which is more than both \cvcd and \ziii.
These results suggest that the translation do not degrade the performance 
of SMT solvers for unsatisfiable problems involving recursive functions, 
and instead often improve their performance. It would be interesting to try this
out in Sledgehammer \cite{blanchette-et-al-2013-smt} and to try Nunchaku as a proof tool.

\section{Related Work}
\label{sec:related-work}

We described the most closely related work, by Ge and de Moura
\cite{GeDeM-CAV-09} and by Reynolds et al.\
\cite{ReyEtAl-1-RR-13,reynolds-et-al-2013}, in the text already.
The finite model finding support in the instantiation-based iProver
\cite{korovin-2013} is also close, given the similarities with SMT.

%Model finding has been studied outside the world of SMT.

Some finite model finders are based on a reduction to a decidable logic,
typically propositional logic. \begin{rep}They translate the input problem to the weaker
logic and pass it to a solver for that logic.\end{rep}
The translation is parameterized by upper or exact finite bounds on
the cardinalities of the atomic types. This procedure was pioneered by McCune
in the earlier versions of Mace (originally styled MACE) \cite{mccune-1994}.
Other conceptually similar finders are Paradox \cite{claessen-sorensson-2003}
and FM-Darwin \cite{baumgartner-et-al-2009} for first-order logic with
equality; the Alloy Analyzer and its back-end Kodkod \cite{torlak-jackson-2007}
for first-order relational logic; and Refute \cite{weber-2008} and Nitpick
\cite{blanchette-nipkow-2010} for higher-order logic.

An alternative is to perform
an exhaustive model search directly on the original problem. Given fixed
cardinalities, the search space is represented as multidimensional
tables. The procedure tries different values in the function and predicate
tables, checking each time if the problem is satisfied.
This approach was pioneered by FINDER
\cite{slaney-1994} and SEM \cite{zhang-zhang-1995} and serves as
the basis of many more model finders, notably the Alloy Analyzer's precursor
\cite{jackson-1996} and the later versions of~Mace
\cite{mccune-prover9-mace4}.

Most of the above tools cannot cope with algebraic datatypes or other infinite
types.
Kuncak and Jackson \cite{kuncak-jackson-2005} presented an idiom for
encoding datatypes and recursive functions in Alloy, by approximating datatypes
by finite subterm-closed substructures. The approach finds sound (fragments
of) models for formulas in the \relax{existential--bounded-universal} fragment%
(i.e., formulas whose prenex normal forms contain no unbounded universal
quantifiers ranging over datatypes). This idiom was further developed by Dunets
et al.\ \cite{dunets-et-al-2010}, who presented a translation scheme
for primitive recursion. Their definedness guards play a similar role to the
existential constraints generated by our translation $\conv$.
An approach related in scope to ours is given in~\cite{baumgartner2013},
which establishes the satisfiability of formulas in the presence of admissible
axioms over infinite domains by proving their negation is entailed.

The higher-order model finder Nitpick \cite{blanchette-nipkow-2010}
for the Isabelle/HOL proof assistant
relies on another variant of Kuncak and Jackson's approach inside a
Kleene-style three-valued logic, inspired by abstract interpretation.
It was also the first tool of its kind to support corecursion and
coalgebraic datatypes \cite{blanchette-2013-relational}.
The three-valued logic approach extends each
approximated type with an unknown value, which is propagated by function
application. This scheme works reasonably well in Nitpick, because it builds
on a relational logic, but our initial experiments with \cvc suggest
that it is more efficient to avoid unknowns by adding existential
constraints.

The Leon system~\cite{blanc2013overview} implements a procedure that can
produce both proofs and counter\-examples for properties of terminating functions
written in a subset of Scala. Leon is based on an SMT solver. It avoids
quantifiers altogether by unfolding recursive definitions up to a certain
depth, which is increased on a per-need basis.
Our translation~$\conv$ works in an analogous manner, 
where instead the SMT solver is invoked only once 
and quantifier instantiation is used in lieu of function unfolding.
It would be
worth investigating how existing approaches for function
unfolding can inform approaches for dedicated quantifier instantiation
techniques for function definitions, and vice versa.

Model finding is concerned with satisfying arbitrary logical constraints. Some
tools are tailored for problems that correspond to total functional
programs. QuickCheck \cite{claessen-hughes-2000} for Haskell is an
early example, based on random testing. Bounded exhaustive testing
\cite{runciman-et-al-2008} and narrowing
\cite{lindblad-2008-testing} are other successful strategies. These
tools are often much faster than model finders, but they typically cannot cope
with underspecification and nonexecutable functions.

% others
%are Agsy for Agda \cite{xxx}, Quickcheck for Isabelle/HOL \cite{xxx}, and
% QuickChick for Coq \cite{xxx}.


%Unlike an SMT solver, Nitpick cannot rely on a built-in notion of
%a datatype; it axiomatizes finite subterm-closed substructures.

%\begin{verbatim}
%Nitpick
%  * nice: three-valued logic (e.g. local overflow)
%    * solving a different problem:
%      * no built-in notion, what's approximated is an idealized notion, no
%        injections $\concret$
%  * not so nice:
%    one abstract domain per type, not per function argument
%  * guards + one-domain per arg are a good combi, guards + one-single-domain is bad because of
%    odd schemes, give unsat example
%    [* show that it works also for example with weird recursion schemes]
%
%  * other features:
%    * inductive / coinductive predicates
%    * quotient types
%
%  * abstract interpretation
%
%Leon
%\end{verbatim}

\section{Conclusion}
\label{sec:conclusion}

We presented a translation scheme that extends the scope of finite model finding 
techniques in SMT, allowing one to use them to find models of quantified formulas 
over \relax{infinite} types, such as integers and algebraic datatypes.
%
In future work, it would be interesting to evaluate the approach against other
counterexample generators, notably Leon, Nitpick, and Quickcheck,
and enrich the benchmark suite with more problems exercising \cvc's support for
coalgebraic datatypes \cite{reynolds-blanchette-2015-codata}.
We are also working on an encoding of higher-order functions in SMT-LIB, as a
generalization to the current translation scheme, for Nunchaku. Further work
would also include identifying additional sufficient conditions for
admissibility, thereby enlarging the applicability of the translation scheme
presented here.

%\ct{?? Leon is a model finder? Alloy?}
%\jb{Alloy has no notion of datatypes, so it's pretty useless. Nitpick implements
%datatypes and a more FOL-like logic (actually, HOL) on top of Alloy's back-end,
%using the Kuncak \& Jackson idiom for Alloy, so that's as close as we can get
%to evaluating Alloy itself. Leon is, in part, a counterexample generator.
%``Model finder'' is probably a stretch.}

{\footnotesize

\def\ackname{Acknowledgment}
\paragraph{%\footnotesize
\ackname.}
Viktor Kuncak and Stephan Merz have made this work possible. We would also like
to thank Damien Busato-Gaston and Emmanouil Koukoutos for providing the
set of Leon benchmarks used in the evaluation, and the anonymous reviewers for their
suggestions and comments. Cruanes is supported by the Inria technological
development action ``Contre-exemples utilisables par Isabelle et Coq'' (CUIC).

}
%

{
\bibliographystyle{abbrv}
\bibliography{bib}
}

\end{document}
