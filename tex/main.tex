\documentclass[runningheads,a4paper]{llncs}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[scaled=.82]{beramono}
\usepackage[scaled=.86]{helvet}
\usepackage{mathptmx}
\usepackage{listings}
\usepackage{colonequals}
%\usepackage{mathpartir}
\usepackage{xspace}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{stmaryrd}
\usepackage{cite}
\usepackage[
   a4paper,
   pdftex,
   pdftitle={Model Finding for Recursive Functions in SMT},
   pdfauthor={Andrew Reynolds, Jasmin Christian Blanchette, and Cesare Tinelli},
   pdfkeywords={},
   pdfborder={0 0 0},
   draft=false,
   bookmarksnumbered,
   bookmarks,
   bookmarksdepth=2,
   bookmarksopenlevel=2,
   bookmarksopen]{hyperref}
\usepackage{framed}

% http://mirror.switch.ch/ftp/mirror/tex/macros/latex/contrib/xcolor/xcolor.pdf
\usepackage{xcolor}

%\usepackage{amsthm}
\usepackage{amsmath}    % need for subequations
\usepackage{booktabs}
%\usepackage{float}
%\usepackage{fullpage}
%\floatstyle{ruled}
%\newfloat{alg}{ht}{loa}
%\floatname{alg}{Algorithm}

\spnewtheorem*{proofsketch}{Proof sketch}{\itshape}{\rmfamily}

\usepackage{url}
\urldef{\mailsa}\path|firstname.lastname@epfl.ch|
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\newcommand\cvcd{CVC4d\xspace}
\newcommand\cvcf{CVC4f\xspace}
\newcommand\cvci{CVC4i\xspace}
\newcommand\ziiib{\ziii}


%\newcommand{\DDD}{\mathcalx{D}}
\newcommand\DDD{\Delta}

%\newcommand\return{$\mathsf{return}$\xspace}
\newcommand\return{}

%\newcommand\bigtuple[1]{$(${#1}$)$}
\newcommand\bigtuple[1]{$\bigl(${#1}$\bigr)$}

%%% for \mathcalx
\DeclareFontFamily{OT1}{pzc}{}
\DeclareFontShape{OT1}{pzc}{m}{it}{<-> s * [1.10] pzcmi7t}{}
\DeclareMathAlphabet{\mathcalx}{OT1}{pzc}{m}{it}

%%% for correctly sized Greek
\DeclareSymbolFont{letters}{OML}{txmi}{m}{it}

%\newcommand\pneg{\neg}
\newcommand\pnegate{-}

\newcommand{\con}[1]{\mathsf{#1}}
\let\const=\con

\renewcommand\vec[1]{\overline{#1}}

\let\oldSigma=\Sigma
\def\Sigma{\mathrm{\oldSigma}}

\let\oldDelta=\Delta
\def\Delta{\mathrm{\oldDelta}}

\def\Chi{\mathrm{X}}

\let\oldneg=\neg
\def\neg{\oldneg\;}

\let\oldvee=\vee
\def\vee{\mathrel{\oldvee}}
\let\oldwedge=\wedge
\def\wedge{\mathrel{\oldwedge}}

\newcommand\win{\bf}
\newcommand\bench{\ttfamily}

%\newcommand{\cvc}{\textsc{cvc}{\small 4}\xspace}
%\newcommand{\cvciii}{\textsc{cvc}{\small 3}\xspace}
%\newcommand{\ziii}{\textsc{z}{\small 3}\xspace}

%%% @ANDY, @CESARE: I hope you'll forgive me these. I find the above fonts
%%% distracting. --JB
\newcommand\cvc{CVC4\xspace}
\newcommand\cvciii{CVC3\xspace}
\newcommand\ziii{Z3\xspace}

\newcommand{\teq}{\approx}
\newcommand{\cc}[1]{#1^*}

%%% I'm trying to avoid bold whenever it can be avoided (except for headings
%%% etc.) --JB
%\newcommand{\terms}{\mathbf{T}}
\newcommand{\terms}{\mathcalx{T}}

%\newcommand{\functerms}{\mathbf{DFT}}
\newcommand{\vars}{\mathbf{V}}
\newcommand{\M}{\mathcalx{M}}
\newcommand{\I}{\mathcalx{J}} %%% there's no difference, right? --JB
%% (I find \mathcalx{I} ugly, with its two horizontal bars, hence the J)
\newcommand{\J}{\mathcalx{J}}
\def\AIF{\qtab\keyword{if}\ }
\def\THEN{\ \keyword{then}\ }
\def\AELSE{\untab\qtab\keyword{else}\ }
\def\FI{\untab}
\def\RETURN{\keyword{return}\ }
\def\ENDPROC{\untab}
%%% @ANDY: I'm trying "A" like "abstraction", again in sync with the abstract--concrete
%%% terminology from abstract interpretation
\newcommand{\conv}{\mathcalx{A}}

%\newcommand{\ssorts}[1]{#1^\mathrm{s}}
\newcommand{\ssorts}[1]{#1^\mathrm{y}}

\newcommand{\sfuns}[1]{#1^\mathrm{f}}
\newcommand{\sfundefs}[1]{#1^\mathrm{dfn}}
%\newcommand{\sfunndefs}[1]{#1^\mathrm{nf}}
\newcommand{\sortint}{\ty{Int}}

\newcommand{\pnone}{\con{apolar}}
\newcommand{\ppos}{\con{pos}}
\newcommand{\pneg}{\con{neg}}
\newcommand{\pol}{\con{pol}}

%\newtheorem{remark}{Remark}

\newcommand\ty[1]{\con{#1}}
\newcommand{\Bool}{\ty{Bool}}
\newcommand{\ltrue}{\top}
\newcommand{\lfalse}{\bot}
\newcommand{\lite}{\con{ite}}

%\newcommand\concret{\con{a}}
%\newcommand\concret{\con{c}}
\newcommand\concret{\gamma} %%% from the abstract interpretation literature

\newcommand{\boolop}{\con{b}}
\newcommand{\forallf}[1]{\forall_{\!#1\:}}
\newcommand{\fnull}{\emptyset}
\newcommand{\vecfarg}[1]{\vec{\concret}_{#1}}
\newcommand{\farg}[1]{\concret_{#1}}
\newcommand{\fargx}[2]{\concret^{\vthinspace#2}_{#1}}
\newcommand{\fargsort}[1]{\alpha_{#1}}

\newcommand{\Sigmalia}{\Sigma_{\mathcalx{LIA}}}
\newcommand{\extendsig}[1]{\mathcalx{E}( #1 )}

\newcommand{\rem}[1]{\textcolor{red}{[#1]}}
\newcommand{\ajr}[1]{\rem{#1 --ajr}}
\newcommand{\jb}[1]{\rem{#1 --jb}}
\newcommand{\ct}[1]{\rem{#1 --ct}}

\newcommand{\negvthinspace}{\kern-0.083333em}
\newcommand{\vthinspace}{\kern+0.083333em}
\newcommand{\typ}[1]{^{\vthinspace #1}}

\newcommand{\definefunreccmd}{\con{define}\text{-}\con{fun}\text{-}\con{rec}}
\newcommand{\definefunsreccmd}{\con{define}\text{-}\con{funs}\text{-}\con{rec}}

\newcommand{\Mo}{{\mathcal{\!J\!}}}

%\newcommand{\euf}{\ensuremath{\mathrm{E}}\xspace}
\newcommand{\euf}{\ensuremath{\mathcalx{UF}}\xspace}
%\newcommand{\ari}{\ensuremath{\mathrm{A}}\xspace}
\newcommand{\ari}{\ensuremath{\mathcalx{A}}\xspace}


%\input{scalalistings}
%\input{smtlib2listings}
\usepackage{program}

\newcommand\xend{{\hfill$\scriptstyle\blacksquare$}}
\renewcommand\qed{{\hfill$\squareforqed$}}

\begin{document}

\title{Model Finding for Recursive Functions in SMT\thanks{%
This research is partially supported by the Inria technological development
action ``Contre-exemples Utilisables par Isabelle et Coq'' (CUIC).
}
}

\author {Andrew Reynolds\inst{1} \and Jasmin Christian Blanchette\inst{2,3} \and Cesare Tinelli \inst{4}}
\authorrunning {A. Reynolds, J. C. Blanchette, C. Tinelli}
\institute{
\'Ecole Polytechnique F\'ed\'erale de Lausanne (EPFL), Switzerland
\and
Inria Nancy \& LORIA, Villers-l\`es-Nancy, France
\and
Max-Planck-Institut f\"ur Informatik, Saarbr\"ucken, Germany
\and
Department of Computer Science, University of Iowa, USA
}

\maketitle

\begin{abstract}

  * finite model finding techniques for satisfiability modulo theories (SMT)
    have emerged in recent years
  * suffer from the major limitation that they cannot handle universal
    quantifiers ranging over infinite types
  * this paper introduces a simple translation to
    produces an equisatifiable problem that avoids infinite quantification
    for a large fragment of recursive functions,
    including terminating, tail-recursive, and productive functions.
  * empirical evaluation confirms that the approach works
  * implemented as a preprocessor in CVC4
\end{abstract}

\section{Introduction}
\label{sec:introduction}

  * why model finding?
  * but SMT solvers better at proving
    * a single universal quantifier in an axiom is enough to put it off track
      (``maybe unsat'')

  * quantifiers in recursive fun defs

  * intuitively, finite quantification suffices:
    * if we make sure all needed values are there
    * if well-founded (assumed!)

  * nasty example (not well-founded)
    * f x = f x + 1

  * how we do it

  * show that it works also for example with weird recursion schemes

  * corecursive functions???
    * productive

\begin{verbatim}
this option targets users who wish to determine the satisfiability of inputs
that involving function definitions that are known to be consistent, whereas it
does not target users who wish to check the consistency of a set of function
definitions.
\end{verbatim}


\ajr{Demand for recursive functions in SMT (new draft includes
define-funs-rec). Usually not interested in showing logical consistency, there
exist other tools that check e.g. termination.
Thus, want SMT solver to check satisfiability the assumption that recursive
functions are consistent (where this needs to be defined precisely).
}

Recent techniques~\cite{GeDeM-CAV-09, ReyEtAl-1-RR-13,reynolds-et-al-2013}
have focused on finding models for quantified formulas in SMT.
Ge and de Moura \cite{GeDeM-CAV-09} presented a complete instantiation-based
procedure for formulas in the \emph{essentially uninterpreted} fragment.
This fragment is limited to universally quantified formulas where all
occurrences of variables occur as direct subterms of uninterpreted
functions. For example, the formula $\forall x%\typ{\sortint} --- the sort is not important, right?
.\;\, \con{f}( x )
\teq \con{g}( x ) + 5$ is in the essentially uninterpreted fragment.
% since all
% occurrences of $x$ occur beneath uninterpreted functions $\con{f}$ and
% $\con{g}$.
Other syntactic criteria are identified in this paper that extend
this fragment slightly, including cases when variables occur as arguments of
arithmetic predicates. The techniques in~Reynolds et al.\
\cite{ReyEtAl-1-RR-13,reynolds-et-al-2013} can be used for finding finite
models for quantified
formulas over uninterpreted types as well as types having a fixed finite
interpretation, such as fixed-width bit vectors and enumerated datatypes.
Finite model finding techniques can
find a model for the formula $\forall x,\, y : \tau.\;\, x \teq
y \vee \neg \con{f}( x ) \teq \con{f}( y )$ where the uninterpreted type $\tau$ is
interpreted as a finite set and $\con{f}$ as injective finite map.

Unfortunately, these fragments cannot accommodate the vast majority of
quantified formulas that correspond to recursive function definitions.
In particular, the fragments in~\cite{GeDeM-CAV-09} are not applicable when the argument of a recursive function is used in various ways (e.g. within an arithmetic expression),
while the fragment in~\cite{ReyEtAl-1-RR-13,reynolds-et-al-2013} is not applicable for functions over infinite domains such as the integers.
So, for instance, the quantified formula $\forall x : {\sortint}.\;\, \lite\bigl( p \leq 0, p( x ) \teq 0, p( x ) \teq 2 * p( x - 1 ) \bigr)$
is not in the essentially uninterpreted fragment (since $x$ occurs as a child of $-$),
nor does finite model finding apply (since $x$ is of type $\sortint$).

In this paper, we advocate a method for translating formulas involving function
definitions (such as the one mentioned in the previous paragraph) 
into ones where the techniques~\cite{GeDeM-CAV-09, ReyEtAl-1-RR-13} are applicable.

\paragraph{Contributions}

In this paper, we make the following contributions:
\begin{itemize}
\item[-] We define a satisfiability-preserving translation method for a class of formulas containing recursive function definitions
that produces formulas for which existing model finding techniques~\cite{GeDeM-CAV-09, ReyEtAl-1-RR-13,reynolds-et-al-2013} are applicable.
\item[-] We provide experimental evidence that this translation improves the effectiveness of SMT solvers \cvc and \ziii for finding counterexamples to verification conditions.
\item[-] We detail front-end support for recursive function definitions and this translation in the SMT solver \cvc.
\end{itemize}

\section{Preliminaries}
\label{sec:prelim}

A \emph{signature} $\Sigma$ consists of
a set $\ssorts{\Sigma}$ of type symbols (or sorts) and
a set $\sfuns{\Sigma}$ of function symbols.
We assume that signatures always include a Boolean type $\Bool$ and constants
$\ltrue$ (truth) and $\lfalse$ (falsity) of that type,
an infix equality predicate ${\teq} : \tau \times \tau \to \Bool$
for each $\tau \in \ssorts{\Sigma}$,
standard boolean connectives ($\neg$, $\wedge$, $\vee$, etc.),
and a function $\lite : \Bool \times \tau \times \tau \rightarrow \tau$ for each $\tau \in \ssorts{\Sigma}$.
We write $t\typ{\tau}$ to denote a metavariable ranging over terms of
type~$\tau$ and $\terms( t )$ to denote the set of subterms in $t$.
%We write $\functerms^\Sigma( t )$ to denote the set of $f$-applications in $t$ such that $f \in \sfundefs{\Sigma}$.

A \emph{$\Sigma$-interpretation $\I$} %is a mathematical structure that
maps each $\tau \in \ssorts{\Sigma}$ to a nonempty set $\tau^\I$,
the \emph{domain} of~$\tau$ in $\I$,
and each $\con{f} : \tau_1 \times \cdots \times \tau_n \rightarrow \tau$ in
$\sfuns{\Sigma}$
to a total function $\con{f}^\I : \tau_1^\I \times \cdots \times \tau_n^\I \rightarrow \tau^\I$.
A \emph{theory} is a pair $T = (\Sigma, \Mo)$ where
$\Sigma$ is a signature and  $\Mo$ is a class of $\Sigma$-interpretations,
the \emph{models} of $T$.
A $\Sigma$-formula $\varphi$ is
\emph{$T$-satisfiable}
if it is satisfied by some interpretation in $\Mo$;
otherwise, it is \emph{$T$-unsatisfiable}.
A formula $\varphi$ entails $\psi$, written $\varphi \models_T \psi$,
if all interpretations in $\Mo$ that satisfy $\varphi$ also satisfy $\psi$.
Given a signature $\Sigma$,
the \emph{theory of equality with uninterpreted functions} \euf
consists of the set of all $\Sigma$-interpretations.
We refer to the type and function symbols in this theory as \emph{uninterpreted}.

In this paper, we consider \emph{annotated quantifed formulas} of the form
$\forallf{a} \vec x.\; \varphi$, where the annotation~$a$ is either
an uninterpreted function $\con{f} \in \sfuns{\Sigma}$ or the special symbol
$\fnull$.
Given $\con{f} : \tau_1 \times \cdots \times \tau_n \rightarrow \tau$,
an annotated
quantified formula $\forallf{\con{f}} \vec x.\; \varphi$ is a \emph{function definition}
(\,\emph{for $\con{f}$}\vthinspace) if $\vec x$ is a tuple of variables of type
$\tau_1, \ldots, \tau_n$ and $\varphi$ is a (quantifier-free) formula equivalent to
$\con{f}( \vec x ) \teq t$ for some $t$. We write $\forall \vec
x.\; \varphi$ as shorthand for $\forallf{\fnull} \vec x.\; \varphi$, and $\exists
\vec x. \varphi$ as shorthand for $\neg \forall \vec x.\; \neg \varphi$.
For a formula $\varphi$,
we write $\varphi[\vec t/\vec x]$ to denote the result of replacing all occurrences of $\vec x$ with $\vec t$.

\begin{definition}%
\rm
A formula $\varphi$ is in \emph{definitional form with respect to} functions $\{
\con{f}_1, \ldots, \con{f}_n \}$ if it is of the form
%
%\kern-\abovedisplayskip
%\kern+\abovedisplayshortskip
%
\begin{equation} \label{eq:wdf}
(\forallf{\con{f}_1} \vec x_1.\; \varphi_1) \wedge \ldots \wedge (\forallf{\con{f}_n} \vec x_n.\; \varphi_n) \wedge \psi
\end{equation}
%
where $\con{f}_1, \ldots, \con{f}_n$ are not $\fnull$ and distinct,
and $\psi$ contains no function definitions.
We call $\psi$ the \emph{conjecture} of $\varphi$.
%\ct{Don't we need additional restrictions on the $\varphi_i$'s here?
%(E.g., they are quantifier-free, or perhaps existential or containing only let binders.)}
% Now fixed above -ajr
\end{definition}

Given a signature $\Sigma$,
we distinguish the subset of \emph{defined} function symbols $\sfundefs{\Sigma}
\subseteq \sfuns{\Sigma}$.
We consider $\Sigma$-formulas that are in definitional form with respect to
functions $\sfundefs{\Sigma}$.

\begin{definition}
Given a set of function definitions $\DDD = \{ \forallf{f_1} \vec x.\; \varphi_1, \ldots, \forallf{f_n} \vec x.\; \varphi_n \}$,
a formula $\varphi$ is \emph{closed under function expansion with respect to $\DDD$} if
\begin{eqnarray}
\varphi \models_T \bigwedge_{i=1}^n \{ \varphi_i[ \vec t / \vec x ] \mid f_i( \vec t ) \in \terms( \varphi ) \}
\end{eqnarray}
The set $\DDD$ is \emph{admissible} if whenever there exists a model for $\varphi$ that is closed under function expansion,
there exists a model for $\varphi \wedge \forallf{f_1} \vec x.\; \varphi_1 \wedge \ldots \wedge \forallf{f_n} \vec x.\; \varphi_n$.
\end{definition}

For instance, the set $\{ \forallf{\con{f}} \vec x.\; \con{f}( x ) \teq 0 \}$ is admissible.
A set of admissible function definitions can include definitions of non-terminating functions, e.g.
$\{ \forallf{\con{f}} x : \sortint.\;\, \con{f}( x ) \teq \con{f}( x - 1 ) \}$ or even $\{ \forallf{\con{f}} x.\;\, \con{f}( x ) \teq \con{f}( x ) \}$ are admissible.
On the other hand, the set $\{ \forallf{\con{f}} x.\;\, \con{f}( x ) \teq \con{f}( x ) + 1 \}$ is not admissible,
since the empty set of formulas is closed under function expansion with respect to this set,
and there is no model satisfying $\forallf{\con{f}} x.\;\, \con{f}( x ) \teq \con{f}( x ) + 1$.
Consider the set $\{ \forallf{\con{f}} x.\;\, \con{f}( x ) \teq \con{f}( x ), \forallf{\con{g}}.\;\, \lite\bigl( \neg \con{f}( x ) \teq 5, \con{g}( x ) \teq \con{g}( x ) + 1, \con{g}( x ) \teq \con{f}( x ) \bigr) \}$.
While this set has a model where $f$ and $g$ are interpreted as the constant $5$, it is not admissible
since the formula $\con{f}( 0 ) \teq 4$ is closed under function expansion with respect to this set,
but there exists no interpretation satisfying both $\con{f}( 0 ) \teq 4$ and $\forallf{\con{g}}.\;\, \lite( \neg \con{f}( x ) \teq 5, \con{g}( x ) \teq \con{g}( x ) + 1, \con{g}( x ) \teq \con{f}( x ) )$.


\jb{TODO: Jasmin: Identify fragments: terminating recursive functions, etc.}

%Terminating function specifications are always admissible, but also some
%nonterminating
%An admissible function definition need not specify a terminating function, e.g.
%$\{ \forallf{\con{f}} x^\sortint.\;\, \con{f}( x ) \teq \con{f}( x - 1 ) \}$ or even $\{ \forallf{\con{f}} x.\;\, \con{f}( x ) \teq \con{f}( x ) \}$ are admissible.

%\section{A Translation for Admissible Function Definitions}
%\section{A Translation for Function Definitions}
\section{The Translation}
\label{sec:encoding}

Let us fix a signature $\Sigma$, a $\Sigma$-formula
$\varphi$ in definitional form with respect to $\sfundefs{\Sigma}$,
whose definitions are admissible.
%We may translate $\varphi$ into a equisatisfiable formula $\psi$ for which known model-finding procedures~\cite{GeDeM-CAV-09, ReyEtAl-1-RR-13} are applicable.
This section presents a method for constructing an extended signature
$\extendsig{ \Sigma }$ and a $\extendsig{ \Sigma }$-formula $\psi$ such that
$\psi$ is satisfiable if and only if $\varphi$ is satisfiable---i.e.,
$\varphi$ and $\psi$ are \emph{equisatisfiable}.
The intuition behind this translation
is to use an uninterpreted type to abstract the set of
\relax{relevant} tuples for each recursive function $\con{f}$ and restrict the
quantification of the function definition for $\con{f}$ to a variable of this
type. Informally, the relevant tuples $\vec t$ of a function $\con{f}$ are the
ones for which the interpretation of $\con{f}( \vec t )$ is relevant to the
satisfiability of $\varphi$.

In more detail,
suppose our signature $\Sigma$ contains a set of defined function symbols $\sfundefs{\Sigma} \subseteq \sfuns{\Sigma}$.
We extend the signature of $\Sigma$ to a signature $\extendsig{\Sigma}$ containing the following additional definitions.
For each $\con{f} : \tau_1 \times \cdots \times \tau_n \rightarrow \tau \in \sfundefs{\Sigma}$,
the signature $\extendsig{\Sigma}$ includes
\begin{itemize}
\item an uninterpreted \emph{abstract type} $\fargsort{\con{f}}$;
\item $n$ uninterpreted \emph{concretization functions} $\fargx{\con{f}}{1} : \fargsort{\con{f}} \rightarrow \tau_1$, \ldots, $\fargx{\con{f}}{n} : \fargsort{\con{f}} \rightarrow \tau_n$.
\end{itemize}
%The interpretation of uninterpreted sort $\fargsort{\con{f}}$ will denote the elements (tuples) on which the function $\con{f}$ is applied.
%The role of the uninterpreted functions $\farg{\con{f}}^1$, $\ldots$, $\farg{\con{f}}^n$ will be discussed more in the following.

The function $\conv$ translates the $\Sigma$-formula
$\varphi$ into an $\extendsig{\Sigma}$-formula. It relies
on the auxiliary function $\conv_0$, which takes two arguments:\ the term $t$
to translate and a \emph{polarity} $p$, which is either $\ppos$, $\pneg$, or
$\pnone$. It returns a pair $( t'\negvthinspace,\, \chi )$, where $t'$ is a term of
type $\tau$ and $\chi$ is an additional constraint.
This constraint is necessary if the polarity is $\pnone$; otherwise, any necessary
constraint is encoded directly in $t'$ and $\chi$ is simply $\ltrue$.

\jb{Merge para above with para below}

A translation function $\conv$ for a $\Sigma$-formula that is in definitional
form with respect to a set of admissible function definitions
$\sfundefs{\Sigma}$. In the auxiliary function $\conv_0$, the function $\pol(
\boolop, i, p )$ returns the polarity of the $i${th} argument of a
$\boolop$ application having polarity $p$, where $\boolop$ is an interpreted
predicate.

\begin{enumerate}
%\begin{framed}
\item[\ ]
$\conv_0( t\typ{\tau},\, p )$ $=$
 \begin{itemize}
   \item[] $\mathsf{if}$ $\tau = \Bool$ and $t = \boolop(t_1,\ldots,t_n)$ $\mathsf{then}$
    \begin{itemize}
      \item[] $\mathsf{let}$ $( t'_i,\, \chi_i ) = \conv_0( t_i,\, \pol( \boolop,\, i,\, p ) )$ $\mathsf{for}$ $i = 1, \ldots, n$ $\mathsf{in}$
      \item[] $\mathsf{let}$ $\chi = \chi_1 \wedge \cdots \wedge \chi_n$ $\mathsf{in}$
      \item[] $\mathsf{if}$ $p = \ppos$ $\mathsf{then}$
      \begin{itemize}
        \item[] \return \bigtuple{$\boolop(t'_1, \ldots, t'_n) ) \wedge \chi,\, \ltrue$}
      \end{itemize}
      \item[] $\mathsf{else}$ $\mathsf{if}$ $p = \pneg$ $\mathsf{then}$
      \begin{itemize}
        \item[] \return \bigtuple{$\boolop(t'_1, \ldots, t'_n) \vee \neg \chi,\, \ltrue$}
      \end{itemize}
      \item[] $\mathsf{else}$
      \begin{itemize}
        \item[] \return \bigtuple{$\boolop(t'_1, \ldots, t'_n),\, \chi$}
      \end{itemize}
    \end{itemize}
  \item[] $\mathsf{else}$ $\mathsf{if}$ $t = \forallf{\con{f}} \vec x.\;\, u$ $\mathsf{then}$
    \begin{itemize}
      \item[] $\mathsf{let}$ $( u',\, \chi ) = \conv_0( u,\, p )$ $\mathsf{in}$
      %\item[] $\mathsf{assert}( \chi = \ltrue )$;
      \item[] \return \bigtuple{$\forall y : \fargsort{\con{f}}.\; u' [ \vecfarg{\con{f}}( y ) / \vec x ],\, \ltrue$}
    \end{itemize}
  \item[] $\mathsf{else}$ $\mathsf{if}$ $t = \forall \vec x.\;\, u$ $\mathsf{then}$
    \begin{itemize}
      \item[] $\mathsf{let}$ $( u',\, \chi ) = \conv_0( u,\, p )$ $\mathsf{in}$
      \item[] \return \bigtuple{$\forall \vec x.\; u',\, \forall \vec x.\; \chi$}
    \end{itemize}
   \item[] $\mathsf{else}$
   \begin{itemize}
     \item[] \return \bigtuple{$t,\; \bigwedge\, \{ \exists a : \fargsort{\con{f}}.\; \vecfarg{\con{f}}( a ) \teq \vec t \mid \con{f}( \vec t ) \in \terms( t ),\, \con{f} \in \sfundefs{\Sigma} \}$}
   \end{itemize}
 \end{itemize}
\end{enumerate}
\begin{enumerate}
%\begin{framed}
\item[\ ]
$\conv( \varphi )$ $=$
 \begin{itemize}
   \item[] $\mathsf{let}$ $( \psi,\, \_ ) = \conv_0( \varphi,\, \ppos )$ $\mathsf{in}$
   %\item[] $\mathsf{assert}( D = \emptyset )$;
   \item[] \return $\psi$
  \end{itemize}
\end{enumerate}

%The role of $D$ is to ensure that
%the (restricted) function definition for $\con{f}$ includes certain tuples in
%its domain, which we explain more in the following.

The translation modifies $\varphi$ in two main ways. First, it restricts the
quantification on function definitions for $\con{f}$ to the corresponding
uninterpreted type $\fargsort{\con{f}}$ and inserts appropriate coercions
$\fargx{\con{f}}{i}$. Second, it augments $\varphi$ with additional constraints
$\exists a : \fargsort{\con{f}}.\;\, \vecfarg{\con{f}}( a ) \teq \vec t$; these
ensure that the restricted definition for $\con{f}$ covers all relevant tuples
of terms, namely the ones for which an $\con{f}$ application exists and is
relevant to the satisfiability of $\varphi$.
%\jb{what does ``current branch of'' mean? can we drop it / rephrase it / vague
%it up?}

If $t$ is an application of an interpreted predicate $\boolop
\in \{{\neg}, {\wedge}, {\vee}, {\teq}, {\lite}\}$,
we recursively call $\conv$ on the arguments $t_i$ and polarity $\pol( \boolop,
i, p )$, where $\pol$ is defined as
\begin{equation*}
\pol( \boolop, i, p ) =
\begin{cases}
p & \text{if either $\boolop \in \{{\wedge}, {\vee}\}$ or $\boolop = \lite$ and $i \in \{2, 3\}$} \\[-\jot]
\pnegate p & \text{if $\boolop = {\neg}$} \\[-\jot]
\pnone & \text{otherwise}
\end{cases}
\end{equation*}
The negation $\pnegate p$ of a polarity $p$ is $\pneg$ if $p$ is $\ppos$, $\ppos$
if $p$ is $\pneg$, and $\pnone$ if $p$ is $\pnone$.

If $t$ has positive polarity, $\conv_0$ adds the constraint $\chi$ derived from
the subterms as a conjunction. Dually, if $t$ has negative polarity, the
function constructs a disjunction with the negated constraint. It $t$ has no
known polarity, the constrained $\chi$ is simply returned to the caller.

If $t$ is a quantified formula, $\conv_0$ recursively calls itself on the body
with the same polarity. If $t$ is a function definition of a function in
$\sfundefs{\Sigma}$, $\conv_0$ constructs a quantified formula over a single variable
$y$ of type $\fargsort{\con{f}}$ and replaces all occurrences of $\vec x$ in
$t'_1$ with $\vecfarg{\con{f}}( y )$.Since function definitions
are a top-level conjunct, %by case analysis on the return values of $\conv$,
we know that $\chi$ is simply $\ltrue$.
If $t$ is not a function definition, the resulting
quantified formula is reconstructed with the body $u'$ returned by the
recursive call, and a quantifier is prefixed to the constraint $\chi$
returned by the call.

Otherwise, $t$ is either an application of an uninterpreted predicate or a term
of a type other than $\Bool$. The returned constraint is a conjunction of
formulas of the form $\exists a : {\fargsort{\con{f}}}.\;\, \vecfarg{\con{f}}(
a ) \teq \vec t$ for each subterm $\con{f}( \vec t )$ of $t$ such that $\con{f}
\in \sfundefs{\Sigma}$. Such constraints, when asserted positively, ensure that
the tuple of uninterpreted functions $\vecfarg{\con{f}}$ must include $\vec t$
in its range.

%We demonstrate this translation with an example.

\begin{example}
\label{ex:translation}
Consider the combined signature of linear arithmetic and uninterpreted
functions $\Sigma = \Sigmalia \mathrel{\cup} \Sigma_{\euf}$, where
$\ssorts{\Sigma_{\euf}} = \{ \sortint \}$ and
$\sfuns{\Sigma_{\euf}} = \{ \con{s} : { \sortint \rightarrow \sortint },\, \const{c} : { \sortint } \}$.
Let $\varphi$ be the $\Sigma$-formula
\begin{equation} \label{eq:ex-before}
\forallf{\con{s}} n : {\sortint}.\;\, \lite\bigl( n \leq 0,\; \con{s}(n) \teq 0,\;
  \con{s}( n ) \teq n + \con{s}( n - 1 ) \bigr) \wedge \con{s}( \con{c} ) > 100
\end{equation}
%
Here, $\const{s}$ is a function that returns the sum of the positive integers
up to $n$. The formula $\varphi$ is in definitional form with
respect to $\sfundefs{\Sigma_u}$ and states that the sum of all
positive numbers between $0$ and $\const{c}$ is greater than $100$. This formula is
satisfiable with a model that interprets $\const{c}$ as an integer greater than or
equal to $14$. Due to the universal quantifier,
current SMT techniques~\cite{GeDeM-CAV-09, ReyEtAl-1-RR-13,reynolds-et-al-2013} are unable to find
a model for this formula. The signature $\extendsig{\Sigma}$ includes the type
$\fargsort{\con{s}}$ and the uninterpreted function $\farg{\con{s}}$ of type $\fargsort{\con{s}}
\rightarrow \sortint$. The result of $\conv( \varphi,\, \ppos )$ is the pair $(
\psi,\, \ltrue )$, where (after simplification) $\psi$ is the
$\extendsig{\Sigma}$-formula
%
\begin{equation} \label{eq:ex-after}
\!\begin{aligned}[c]
  & \phantom{{\wedge}\; }\bigl(
      \forall a : \fargsort{\con{s}}.\; \lite\bigl(
        \!\begin{aligned}[t]
         &  \farg{\con{s}}( a ) \leq 0,\;
          \con{s}(\farg{\con{s}}( a )) \teq 0,\;
\\[-\jot]
  & \con{s}(\farg{\con{s}}( a )) \teq \farg{\con{s}}( a ) + \con{s}( \farg{\con{s}}( a )-1 )
    \wedge \exists b : {\fargsort{\con{s}}}.\;\, \farg{\con{s}}( b ) \teq \farg{\con{s}}( a )-1 \bigr) \bigr)
\end{aligned}
\\[-\jot]
 & {\wedge}\; \bigl( \con{s}( \con{c} ) > 100 \wedge \exists a : {\fargsort{\con{s}}}.\;\, \farg{\con{s}}( a ) \teq \con{c} \bigr)
\end{aligned}
\end{equation}
%
The universal quantification in the resulting formula is over an uninterpreted
type $\fargsort{\con{s}}$, thus enabling the finite model finding
techniques by Reynolds et al.\ \cite{ReyEtAl-1-RR-13,reynolds-et-al-2013} to search for a finite interpretation for
$\fargsort{\con{s}}$. Moreover, all occurrences of $a$ in this formula are beneath
applications of the uninterpreted function $\farg{\con{s}}$, implying that the
formula is in the essentially uninterpreted fragment,
for which Ge and de Moura \cite{GeDeM-CAV-09} provide a complete instantiation
procedure. Both
%%% Added "apparently". Or are we sure?  
% Yes, I'm planning to post the 2 versions of the benchmark on the evaluation page (when we add it) --ajr
\cvc and \ziii run indefinitely on formula~(\ref{eq:ex-before}), and both
produce a model for formula~(\ref{eq:ex-after}) within 100 milliseconds.\xend
\end{example}

The translation $\conv$ does not preserve the models of $\varphi$.
One model $\I$ for formula~(\ref{eq:ex-after}) in the previous example interprets
$\fargsort{\con{s}}$ as a finite set of elements $\{ u_0, \ldots, u_{14} \}$,
$\farg{\con{s}}$ as a finite map $u_i \mapsto i$ for $i = 0, \ldots, 14$,
$\con{c}$ as $14$,
and $\con{s}$ as the (almost constant) function
%
%% TYPESETTING: \mathbin and to make it fit nicely
\begin{equation} \label{eq:approx-interp}
\lambda x : \sortint.\;\, \lite( x \mathbin{\teq} 0,\, 0,\,
  \lite( x \mathbin{\teq} 1,\, 1,\,
    \lite( x \mathbin{\teq} 2,\, 3,\,
      \lite(\ldots,\; \lite( x \mathbin{\teq} 13,\, 91,\, 105 )\negvthinspace \ldots ))))
\end{equation}
%
In other words, $\const{s}$ is interpreted as a function mapping $x$ to the sum
of all positive integers between $0$ and $x$ when $0 \leq x \leq 13$, and $105$
otherwise.
The interpretation $\I$, restricted to $\Sigma$, is {not} a model for the original formula~(\ref{eq:ex-before}),
since $\I$ wrongly interprets $\con{s}( x )$ as $105$ when $x < 0$ or $x > 14$.

However, under the assumption that the function definitions in
$\sfundefs{\Sigma}$ are admissible, %we claim that
$\conv(\varphi)$ is
equisatisfiable with $\varphi$ for any input $\varphi$. The intuition is that the
interpretation of a term such as $\con{s}( -1 )$ in the previous example is not
relevant to the satisfiability of formula~(\ref{eq:ex-before}). Thus, a
satisfiable or unsatisfiable response from an SMT solver on input $\conv(
\varphi )$ implies the existence or nonexistence of a model for
$\varphi$. Moreover, information in models for $\conv( \varphi )$ contains
pertinent information regarding the models of $\varphi$. For example, the model
$\I$ for formula~(\ref{eq:ex-after}) described above interprets $\con{c}$ as $14$,
and there exists a model of formula~(\ref{eq:ex-before}) that also interprets $\con{c}$
as $14$. In general, there exists a model of $\varphi$ that
coincides with each model of $\conv( \varphi )$ on its interpretation of all
functions in $\sfuns{\Sigma} - \sfundefs{\Sigma}$, i.e., $\{
\con{s} \}$ in the example.

%%% @ANDY: I don't get the following comment --jb
%   @JASMIN : The point of this comment is that the user is not interested in the SMT solver inferring any new information regarding the interpretation of s,
%             since s is a "defined" function, the user already has an intended interpretation in their head of what s is (here, the sum of positive integers between 0...x).
%             Thus, it isn't a big deal that the SMT solver "approximates" the interpretation of s during a check, since we already know what s is.
%From a practical point of view, this is not an
%issue, because $s$ is the very function that was explicitly defined by the
%user, and hence already has an intended interpretation.

\begin{theorem}\label{thm:equi}
If $\varphi$ is a\/ $\Sigma$-formula that is in definitional form with respect to\/
$\sfundefs{\Sigma}$
and the set of function definitions\/ $\DDD$ corresponding to functions in
$\sfundefs{\Sigma}$ is admissible, then\/ $\varphi$ and\/ $\conv( \varphi )$ are
equisatisfiable.
\end{theorem}
\begin{proofsketch}
First, we show that if $\varphi$ is satisfied by $\Sigma$-interpretation $\I$, then $\conv( \varphi )$ is satisfied by a $\extendsig{\Sigma}$-interpretation $\J$.
Let $\J$ be the $\extendsig{\Sigma}$-interpretation that interprets all types $\tau \in \ssorts{\Sigma}$ as $\tau^\I$,
all functions $\con{f} \in \sfuns{\Sigma}$ as $\con{f}^\I$,
and for each function $\con{f}$ of type $\tau_1 \times \cdots \tau_n \rightarrow \tau$ in $\sfundefs{\Sigma}$,
interprets $\fargsort{\con{f}}$ as a tuple of values of type $\tau_1^\I \times \cdots \times \tau_n^\I$,
and each $\fargx{\con{f}}{i}$ as the $i^{th}$ projection on such tuples for each $i = 1, \ldots, n$.
Note that $\J$ satisfies \emph{every} constraint of the form $\exists a : {\fargsort{\con{f}}}. ( \vecfarg{\con{f}}( a ) \teq \vec t )$,
since by our construction of $\J$ there exists an $a$ such that $a^\J = \vec t^\J$.
By case analysis it follows that $\conv_0$ maintains the invariant that
if $\conv_0( t\typ{\Bool}, \ppos )$ returns $( {t'}, \chi )$,
then $\I$ satisfies $t$ if and only if $\J$ satisfies $t'$.
Thus, we conclude $\J$ is a model of $\conv( \varphi )$.

Second, we show that if $\conv( \varphi )$ is satisfied by a
$\extendsig{\Sigma}$-interpretation $\I$, then $\varphi$ is satisfied by
$\Sigma$-interpretation $\J$. Since $\varphi$ is in definitional form with
respect to the functions defined by $\DDD$, we know $\varphi$ is of the form
$\DDD \wedge \varphi_0$. We first argue that $\I$ satisfies a $\Sigma$-formula
$\psi$ that is closed under function expansion with respect to $\DDD$, and
where $\psi$ entails $\varphi_0$.

Since there exists a model for $\psi$ that is closed under function expansion
with respect to $\DDD$, then since $\DDD$ is admissible, by definition there
exists a model for $\psi \wedge \DDD$, which entails $\DDD \wedge \varphi_0$,
which is $\varphi$.
\qed
\end{proofsketch}

\begin{example}
Let us revisit the translated formula~(\ref{eq:ex-after}) from
Example~\ref{ex:translation}. This formula is unsatisfiable if and only if
formula~(\ref{eq:ex-before}) is unsatisfiable since $\fargsort{f}$ can be
interpreted as $\sortint$, and $\farg{f}$ can be interpreted as the identity
function. Conversely, we claim formula~(\ref{eq:ex-after}) is satisfiable if
and only if formula~(\ref{eq:ex-before}) is satisfiable, noting that the set
$\{ \forallf{\con{s}} x\typ{\sortint}.\;\, \lite\bigl( x \leq 0, \con{s}(x)
\teq 0, \con{s}( x ) \teq x + \con{s}( x-1 ) \bigr) \}$ is admissble.
As stated
in the proof of Theorem~\ref{thm:equi}, the reason is that any model of
formula~(\ref{eq:ex-after}) must satisfy a formula that is closed under
function expansion, hence implying that formula~(\ref{eq:ex-before}) has a
model. In more detail, let $\varphi_\con{s}$ be the formula $\forallf{\con{s}} x.\;\,
\lite\bigl( x \leq 0, \con{s}(x) \teq 0, \con{s}( x ) \teq x + \con{s}( x-1 )
\bigr)$. The rightmost conjunct $\exists a : {\fargsort{\con{s}}}.
\farg{\con{s}}( a ) \teq \con{c}$ ensures that any model of
formula~(\ref{eq:ex-after}) satisfying $\con{s}( \con{c} ) > 100$ also
satisfies $\varphi_{\con{s}}[\con{c}/x]$. The nested existential
$\exists b.\;\, \farg{\con{s}}( b ) \teq \farg{\con{s}}( a )-1$ ensures that
a similar constraint is enforced recursively: any model satisfying $\varphi_{\con{s}}[t/x]$
must also satisfy $\varphi_{\con{s}}[t-1/x]$ when $t > 0$. Given a model $\I$ of
formula~(\ref{eq:ex-after}) that interprets $\con{c}$ as $14$, it is easy to see that
due to the structure of formula~(\ref{eq:ex-after}),
$\I$ must satisfy the following formula $\psi$:
%
\begin{equation} \label{eq:fun-closure}
\begin{split}
& \con{s}( \con{c} ) > 100 \wedge %\displaystyle
  \bigwedge\nolimits_{\vthinspace i=0}^{\!13} \bigl( \neg (\con{c}-i \leq 0) \wedge \con{s}( \con{c}-i ) \teq i + \con{s}( \con{c}-i-1 ) \bigr) \\[-\jot]
{\wedge}\; & \con{c}-14 \leq 0 \wedge \con{s}( \con{c}-14 ) \teq 0
\end{split}
\end{equation}
%
This formula is closed under function expansion,
since it contains the $\con{s}$ applications corresponding to
$\con{s}( \con{c}-i )$ for $i = 0, \ldots, 14$. The formula also
entails $\varphi_\con{s}[\con{c}-i/x]$ for $i = 0, \ldots, 14$.
Since $\varphi_\con{s}$ is an admissible definition,
there must exist a model for $\psi \wedge \varphi_\con{s}$,
which means there exists a model for formula~(\ref{eq:ex-before}).\xend
\end{example}

\section{Evaluation}
\label{sec:evaluation}

In this section, we evaluate both the overall impact of the encoding introduced
in the previous section, and the performance of individual SMT techniques for
benchmarks in the encoding.

We gathered a set of 245 benchmarks from two sources, which we will refer to as
{\bench isa} and {\bench leon}. The first ({\bench isa}) consists of the 79
benchmarks from the Isaplanner benchmark
suite~\cite{DBLP:conf/itp/JohanssonDB10} that do not contain higher-order
functions. The benchmarks have been used recently as challenge problems for a
variety of inductive theorem provers. These benchmarks heavily involve
recursive functions, and are limited to the combined theory of uninterpreted
functions and inductive datatypes. The second ({\bench leon}) consists of 166
benchmarks from the Leon repository,\footnote{%Available at
\url{https://github.com/epfl-lara/leon}} which were constructed from
verification conditions from simple Scala programs. These benchmarks also
heavily involve recursive functions over inductive datatypes, and also cover a
wide variety of theories, including bit vectors, arrays, and linear and
nonlinear arithmetic. Each benchmark is in definitional form with respect to a
set of terminating functions.
%
% in particular they each
%are a conjoined list of function definitions followed by a (negated)
%conjecture.
A majority of these benchmarks are unsatisfiable, although a
handful of the benchmarks in the {\bench leon} set are satisfiable.

For each of these 245 benchmarks, we considered (up to) three randomly selected mutated forms of its conjecture $\psi$.
In particular, we considered unique conjectures that are obtained as a result of swapping a subterm of $\psi$ at one position
with another of the same type at another position.
Note that benchmarks created in this way have a high likelihood of having small and easy-to-find counterexamples.
In total, we considered 213 mutated forms of conjectures from {\bench isa}, and 427 mutated forms of conjectures from {\bench leon}.
We will call these sets {\bench isa+m} and {\bench leon+m} respectively.

In total, our benchmark set consisted of 885 benchmarks (640 mutants plus the original 245).
We considered these 885 benchmarks both before and after the translation $\conv$ as described in Section~\ref{sec:encoding}.
For example, {\bench isa} contains 79 original benchmarks $\varphi$
and 79 translated benchmarks $\conv(\varphi)$.

For solvers, we considered the SMT solver \ziii~\cite{de-moura-bjoerner-2008},
which runs both heuristic methods for quantifier instantiation~\cite{DBLP:conf/cade/MouraB07},
as well as methods for finding models for quantified formulas~\cite{GeDeM-CAV-09}.
We also considered three configurations of \cvc~\cite{barrett-et-al-2011} which we will refer to as \cvcd, \cvcf, and \cvci.
The default configuration \cvcd runs heuristic quantifier instantiation,
but does not include techniques for finding models.
The configuration \cvcf runs heuristic instantiation and the finite model finding procedure described in~\cite{ReyEtAl-1-RR-13,reynolds-et-al-2013}.
The last configuration \cvci incorporates techniques for automating inductive reasoning in SMT~\cite{reynolds-kuncak-2015}.
%All configurations of \cvc incorporate techniques for conflict-based instantiation~\cite{} ..?

\begin{figure}[t]
\normalsize
\centering
\begin{tabular}{l@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\,\,}}
  & \multicolumn{2}{c@{\kern1.5em}}{\phantom{0}\ziiib}     & \multicolumn{2}{c@{\kern1.5em}}{\phantom{0}\cvcd}     & \multicolumn{2}{c@{\kern1.5em}}{\phantom{0}\cvcf}     & \multicolumn{2}{c@{\,\,}}{\phantom{0}\cvci}
\\%[-1pt]
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
\\
\midrule
{\bench isa} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0
\\
{\bench leon}  & 0 & 2 & 0 & 0 & 0 & {\win 9} & 0 & 0
\\
{\bench isa+m} & 0 & 35 & 0 & 0 & 0 & {\win 153} & 0 & 0
\\
{\bench leon+m}  & 11  & 75 & 6 & 6 & 6 & {\win 169} & 6 & 6
\\[\jot]
Total & \phantom{0}11  & 112 & \phantom{00}6 & \phantom{00}6 & \phantom{00}6 & {\win 331} & \phantom{00}6 & \phantom{00}6
\end{tabular}
\caption{\,Number of ``satisfiable'' responses on benchmarks without and with translation with $\conv$}
\label{fig:sat}
\end{figure}

\begin{figure}[t]
\normalsize
\centering
\begin{tabular}{l@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\,\,}}
  & \multicolumn{2}{c@{\kern1.5em}}{\phantom{0}\ziiib}     & \multicolumn{2}{c@{\kern1.5em}}{\phantom{0}\cvcd}     & \multicolumn{2}{c@{\kern1.5em}}{\phantom{0}\cvcf}     & \multicolumn{2}{c@{\,\,}}{\phantom{0}\cvci}
\\%[-1pt]
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
\\
\midrule
{\bench isa} & 14  & 15 & 15  & 15 & 15  & 15 & {\win 61}  & 14
\\
{\bench leon}  & 73  & 78 & 80  & 80 & 80  & 76 & {\win 96}  & 78
\\
{\bench isa+m} & 17  & 18 & 18  & 18 & 18  & 18 & {\win 44}  & 17
\\
{\bench leon+m}  & 83  & 98 & 103 & 98 & 104 & 95 & {\win 117} & 98
\\[\jot]
Total & 187 & 209 & 216 & 211 & 217 & 204 & {\win 318} & 217
\end{tabular}
\caption{\,Number of ``unsatisfiable'' responses on benchmarks without and with translation with $\conv$}
\label{fig:unsat}
\end{figure}

The results are shown in Figures \ref{fig:sat} and \ref{fig:unsat}.
The results are divided into benchmarks triggering ``unsatisfiable'' and ``satisfiable''
responses and further into benchmarks before and after the translation $\conv$.
The raw evaluation data reveals no cases in which a solver answered
``unsatisfiable'' on a benchmark $\varphi$ and ``satisfiable'' on its
corresponding benchmark $\conv( \varphi )$, or vice versa, thereby
corroborating Theorem~\ref{thm:equi}.

Figure~\ref{fig:sat} shows that for untranslated benchmarks (the ``$\varphi$''
columns), the number of satisfiable responses is very low, across all
configurations. This confirms the shortcomings of existing SMT techniques for
finding counterexamples for benchmarks containing recursive functions.
%
The translation $\conv$ (the ``$\conv(\varphi)$'' columns) has a major
impact. \cvcf finds 331 of the 885 benchmarks to be satisfiable,
including 9~benchmarks in the unmutated {\bench leon} benchmark set. The
performance of \ziiib for counterexamples also improves dramatically, as it
solves 112 satisfiable problems, including 10 that were unsolved by \cvcf.
%
We conclude that the translation $\conv$ enables SMT
solvers to find counterexamples for conjectures involving recursive functions
whose definitions are admissible.
%Both \ziiib and \cvcf were able to find a
%large number of counterexamples after the translation, with the latter
%configuration finding significantly more instances (331 to 112).

In terms of number of unsatisfiable responses, the configuration \cvci is the
clear winner, finding 318 total benchmarks to be unsatisfiable. Moreover, the
translation $\conv$ helps \ziii for ``unsatisfiable'' responses as well, as we
see \ziii solves a total of 209 whereas it solves only 187 before the
translation.
%
This number is 2 fewer than \cvcd, which solves 211 unsatisfiable. Thus, in
most cases the translation $\conv$ does not significantly degrade performance
for unsatisfiable benchmarks, and in some cases may actually aid the solver for
determining unsatisfiability. The exception here is \cvci, whose inductive
arguments are guided by the types of quantified variables.

\section{Front-End Support %for Recursive Function Definitions
  in CVC4}
\label{sec:front-end}

The translation $\conv$ significantly improves the effectiveness of known SMT
techniques for finding counterexamples for formulas involving recursive
function definitions.
For the convenience of end users, it
has been implemented in the latest development version of \cvc %~\cite{ReyEtAl-1-RR-13}
(version~1.5 prerelease).
Function definitions $\forallf{\con{f}} \vec x.\; \varphi$ can be written in using the $\definefunreccmd$ command,
from the SMT-LIB 2.5 draft standard \cite{smtlib25}.
For example, formula~(\ref{eq:ex-before}) from Example~\ref{ex:translation}
can be specified as
%
\begin{quote}
\begin{verbatim}
(define-fun-rec s ((n Int)) Int (ite (<= n 0) 0 (+ n (s (- n 1)))))
(declare-fun c () Int)
(assert (> (s c) 100))
(check-sat)
\end{verbatim}
\end{quote}
%
When reading this input,
\cvc adds the annotated quantified formula
$$\forallf{\con{s}} x.\;\, \con{s}( x ) \teq \lite\bigl( x \leq 0,\; 0,\; \con{s}( x-1 )\bigr)$$
to its list of assertions,
which after rewriting becomes
$$\forallf{\con{s}} x.\;\, \lite\bigl( x \leq 0,\; \con{s}( x ) \teq 0,\; \con{s}( x ) \teq \con{s}( x-1 ) \bigr)$$
If \cvc's finite model finding mode for recursive functions is enabled (using
the command-line option \texttt{--fmf-fun}), it will replace its list of known
assertions based on the conversion $\conv$ before checking for satisfiability.
%If the functions provided in the input are admissible,
%then a ``satisfiable" response from the solver implies that a model exists for the original formula.
Accordingly, the solver will output the approximation of the interpretation it
used for recursive function definitions. For our example, it will output the following
model:
\ajr{prefer having the full output like this here?}
\jb{I like it the way you did it now, but I took the freedom to reformat the output slightly
(to avoid the small font---I generally try to avoid ad hoc font mixtures---and to show
the nesting more clearly).}
%it may output the interpretation~(\ref{eq:approx-interp}) from Section~\ref{sec:encoding} for $s$.
%
\begin{quote}
\begin{verbatim}
(model
  (define-fun s (($x1 Int)) Int 
     (ite (= $x1 14) 105 (ite (= $x1 13) 91 (ite (= $x1 12) 78 
        (ite (= $x1 11) 66 (ite (= $x1 10) 55 (ite (= $x1 4) 10 
           (ite (= $x1 9) 45 (ite (= $x1 8) 36 (ite (= $x1 7) 28 
              (ite (= $x1 6) 21 (ite (= $x1 3) 6 (ite (= $x1 5) 15 
                 (ite (= $x1 2) 3 (ite (= $x1 1) 1 0)))))))))))))))
  (define-fun c () Int 14)
)
\end{verbatim}
\end{quote}

The \texttt{--fmf-fun} option instructs CVC4 to assume that the
functions provided by the user are admissible.
If this condition is not met, the solver may answer ``satisfiable'' on
an unsatisfiable problem. For example, if we add the inconsistent definition
%
\begin{quote}
\begin{verbatim}
(define-fun-rec e ((n Int)) Int (+ (e n) 1))
\end{verbatim}
\end{quote}
%
to the above problem, CVC4 will still find the same ``model''
if \texttt{--fmf-fun} is specified.

\section{Related Work}

\begin{verbatim}
first-order model finders: SEM, MACE/Mace, Paradox, FMDarwin, iProver
  either direct search or reduction to SAT

Alloy (and Alloy idiom by Kuncak \& Jackson), Kodkod

The model finder for KIV based on Alloy

Refute
  * unsound handling of datatypes

Nitpick
  * nice: three-valued logic (e.g. local overflow)
    * solving a different problem:
      * no built-in notion, what's approximated is an idealized notion, no
        injections $\concret$
  * not so nice:
    one abstract domain per type, not per function argument
  * guards + one-domain per arg are a good combi, guards + one-single-domain is bad because of
    odd schemes, give unsat example

  * other features:
    * inductive / coinductive predicates
    * quotient types

  * abstract interpretation

Leon

in smt : z3, cvc4 (briefly, text in main section gives detail)
\end{verbatim}

\section{Conclusion}
\label{sec:conclusion}

\begin{verbatim}
  * future work
    * more eval
      * against other non-SMT-solvers (notably Leon and Nitpick)
      * problems exercising codatatypes (which CVC4 supports \cite{xxx}) and
        corecursive functions
    * more features
      * e.g. encode (co)inductive predicates as (co)recursive functions
\end{verbatim}

{%\footnotesize
\def\ackname{Acknowledgment}
\paragraph{%\footnotesize
\ackname.}
We would like to thank Damien Busato-Gaston and Emmanouil Koukoutos for
providing the initial set of benchmarks used in the evaluation.
}



{
\bibliographystyle{abbrv}
\bibliography{bib}
}

\end{document}
