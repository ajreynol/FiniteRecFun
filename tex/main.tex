\documentclass[runningheads,a4paper]{llncs}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[scaled=.82]{beramono}
\usepackage[scaled=.86]{helvet}
\usepackage{mathptmx}
\usepackage{listings}
\usepackage{colonequals}
%\usepackage{mathpartir}
\usepackage{xspace}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{stmaryrd}
\usepackage{cite}
\usepackage[
   a4paper,
   pdftex,
   pdftitle={Model Finding for Recursive Functions in SMT},
   pdfauthor={Andrew Reynolds, Jasmin Christian Blanchette, and Cesare Tinelli},
   pdfkeywords={},
   pdfborder={0 0 0},
   draft=false,
   bookmarksnumbered,
   bookmarks,
   bookmarksdepth=2,
   bookmarksopenlevel=2,
   bookmarksopen]{hyperref}
\usepackage{framed}

% http://mirror.switch.ch/ftp/mirror/tex/macros/latex/contrib/xcolor/xcolor.pdf
\usepackage{xcolor}

%\usepackage{amsthm}
\usepackage{amsmath}    % need for subequations
\usepackage{booktabs}
%\usepackage{float}
%\usepackage{fullpage}
%\floatstyle{ruled}
%\newfloat{alg}{ht}{loa}
%\floatname{alg}{Algorithm}

\spnewtheorem*{proofsketch}{Proof sketch}{\itshape}{\rmfamily}

\usepackage{url}
\urldef{\mailsa}\path|firstname.lastname@epfl.ch|
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\newcommand\cvcd{{\cvc}d\xspace}
\newcommand\cvcf{{\cvc}f\xspace}
\newcommand\cvci{{\cvc}i\xspace}
\newcommand\ziiib{\ziii}

\renewcommand\models{\mathrel{\vDash}}

%\newcommand{\DDD}{\mathcalx{D}}
\newcommand\DDD{\Delta}

%\newcommand\return{$\mathsf{return}$\xspace}
\newcommand\return{}

%\newcommand\bigtuple[1]{$(${#1}$)$}
\newcommand\bigtuple[1]{$\bigl(${#1}$\bigr)$}

%%% for \mathcalx
\DeclareFontFamily{OT1}{pzc}{}
\DeclareFontShape{OT1}{pzc}{m}{it}{<-> s * [1.10] pzcmi7t}{}
\DeclareMathAlphabet{\mathcalx}{OT1}{pzc}{m}{it}

%%% for correctly sized Greek
\DeclareSymbolFont{letters}{OML}{txmi}{m}{it}

%\newcommand\pneg{\neg}
\newcommand\pnegate{-}
%\newcommand\pnegate{{\sim}}

\newcommand{\con}[1]{\mathsf{#1}}
\let\const=\con

\renewcommand\vec[1]{\overline{#1}}

\let\oldchi=\chi
\def\chi{{\vthinspace\oldchi}}

\let\oldSigma=\Sigma
\def\Sigma{\mathrm{\oldSigma}}

\let\oldDelta=\Delta
\def\Delta{\mathrm{\oldDelta}}

\def\Chi{\mathrm{X}}

\let\oldneg=\neg
\def\neg{\oldneg\;}

\let\oldvee=\vee
\def\vee{\mathrel{\oldvee}}
\let\oldwedge=\wedge
\def\wedge{\mathrel{\oldwedge}}

\newcommand\win{\bf}
%\newcommand\bench{\ttfamily}

\newcommand\isa{Isa\xspace}
\newcommand\isam{Isa-Mut\xspace}
\newcommand\leon{Leon\xspace}
\newcommand\leonm{Leon-Mut\xspace}

%\newcommand{\cvc}{\textsc{cvc}{\small 4}\xspace}
%\newcommand{\cvciii}{\textsc{cvc}{\small 3}\xspace}
%\newcommand{\ziii}{\textsc{z}{\small 3}\xspace}

%%% @ANDY, @CESARE: I hope you'll forgive me these. I find the above fonts
%%% distracting. --JB
\newcommand\cvc{CVC4\xspace}
\newcommand\cvciii{CVC3\xspace}
\newcommand\ziii{Z3\xspace}

\newcommand{\teq}{\approx}
\newcommand{\cc}[1]{#1^*}

%%% I'm trying to avoid bold whenever it can be avoided (except for headings
%%% etc.) --JB
%\newcommand{\terms}{\mathbf{T}}
\newcommand{\terms}{\mathcalx{T}}

%\newcommand{\functerms}{\mathbf{DFT}}
\newcommand{\vars}{\mathbf{V}}
\newcommand{\M}{\mathcalx{M}}
\newcommand{\I}{\mathcalx{I}}
\newcommand{\J}{\mathcalx{J}}
\def\AIF{\qtab\keyword{if}\ }
\def\THEN{\ \keyword{then}\ }
\def\AELSE{\untab\qtab\keyword{else}\ }
\def\FI{\untab}
\def\RETURN{\keyword{return}\ }
\def\ENDPROC{\untab}
%%% @ANDY: I'm trying "A" like "abstraction", again in sync with the abstract--concrete
%%% terminology from abstract interpretation
\newcommand{\conv}{\mathcalx{A}}

%\newcommand{\stypes}[1]{#1^\mathrm{s}}
\newcommand{\stypes}[1]{#1^\mathrm{ty}}

\newcommand{\sfuns}[1]{#1^\mathrm{f}}
\newcommand{\sfundefs}[1]{#1^\mathrm{dfn}}
%\newcommand{\sfunndefs}[1]{#1^\mathrm{nf}}
\newcommand{\typeint}{\ty{Int}}

%\newcommand{\pnone}{\con{none}}
%\newcommand{\ppos}{\con{pos}}
%\newcommand{\pneg}{\con{neg}}
%%% @ANDY: as usual, revert if you don't like
\newcommand{\pnone}{{\pm}}
\newcommand{\ppos}{{+}}
\newcommand{\pneg}{{-}}
\newcommand{\pol}{\con{pol}}

%\newtheorem{remark}{Remark}

\newcommand\ty[1]{\con{#1}}
\newcommand{\Bool}{\ty{Bool}}
\newcommand{\ltrue}{\top}
\newcommand{\lfalse}{\bot}
\newcommand{\lite}{\con{ite}}

%\newcommand\concret{\con{a}}
%\newcommand\concret{\con{c}}
\newcommand\concret{\gamma} %%% from the abstract interpretation literature

\newcommand{\boolop}{\con{b}}
\newcommand{\forallf}[1]{\forall_{\!#1\:}}
\newcommand{\fnull}{\emptyset}
\newcommand{\vecfarg}[1]{\vec{\concret}_{#1}}
\newcommand{\farg}[1]{\concret_{#1}}
\newcommand{\fargx}[2]{\concret_{#1,#2}}
\newcommand{\fargtype}[1]{\alpha_{#1}}

\newcommand{\Sigmalia}{\Sigma_{\mathcalx{LIA}}}
\newcommand{\extendsig}[1]{\mathcalx{E}( #1 )}

\newcommand{\rem}[1]{\textcolor{red}{[#1]}}
\newcommand{\ajr}[1]{\rem{#1 --ajr}}
\newcommand{\jb}[1]{\rem{#1 --jb}}
\newcommand{\ct}[1]{\rem{#1 --ct}}

\newcommand{\negvthinspace}{\kern-0.083333em}
\newcommand{\vthinspace}{\kern+0.083333em}
\newcommand{\vvthinspace}{\kern+0.0416666em}
\newcommand{\typ}[1]{^{\vthinspace #1}}

\newcommand{\definefunreccmd}{\con{define}\text{-}\con{fun}\text{-}\con{rec}}
\newcommand{\definefunsreccmd}{\con{define}\text{-}\con{funs}\text{-}\con{rec}}

\newcommand{\Mo}{{\mathcal{I}}}

%\newcommand{\euf}{\ensuremath{\mathrm{E}}\xspace}
\newcommand{\euf}{\ensuremath{\mathcalx{UF}}\xspace}
%\newcommand{\ari}{\ensuremath{\mathrm{A}}\xspace}
\newcommand{\ari}{\ensuremath{\mathcalx{A}}\xspace}

\newcommand{\absconstraints}{X}

\newtheorem{cor}{Corollary}

%\input{scalalistings}
%\input{smtlib2listings}
\usepackage{program}

\newcommand\xend{{\hfill$\scriptstyle\blacksquare$}}
\renewcommand\qed{{\hfill$\squareforqed$}}

\begin{document}

\title{Model Finding for Recursive Functions in SMT\thanks{%
This research is partially supported by the Inria technological development
action ``Contre-exemples Utilisables par Isabelle et Coq'' (CUIC).
}
}

\author {Andrew Reynolds\inst{1} \and Jasmin Christian Blanchette\inst{2,3} \and Cesare Tinelli \inst{4}}
\authorrunning {A. Reynolds, J. C. Blanchette, C. Tinelli}
\institute{
\'Ecole Polytechnique F\'ed\'erale de Lausanne (EPFL), Switzerland
\and
Inria Nancy \& LORIA, Villers-l\`es-Nancy, France
\and
Max-Planck-Institut f\"ur Informatik, Saarbr\"ucken, Germany
\and
Department of Computer Science, University of Iowa, USA
}

\maketitle

\begin{abstract}
Model finding in SMT solvers is
generally limited to universally quantified formulas in some restricted fragment.
This paper introduces a translation which reduces axioms specifying a large
class of recursive functions, including terminating and
productive functions to universally quantified formulas for which known
techniques are applicable.
An empirical evaluation confirms that the approach improves 
the performance of existing solvers on benchmarks from two sources. 
The translation is implemented as a preprocessor in the solver CVC4.
\end{abstract}

%% The institutions above shouldn't count as footnotes
\setcounter{footnote}{0}

\section{Introduction}
\label{sec:introduction}

%\ct{The paper used "recursive datatype" in some places and "inductive datatype" in others. I have replaced both by "algebraic datatype" which is more accurate for \cvc.
%("recursive datatype" is a more general notion and "inductive datatype" has a stronger meaning in higher-order logics.)}  
%% I agree --JB.

Many solvers based on SMT (satisfiability modulo theories) can reason about
quantified formulas using incomplete instantiation-based methods
\cite{MouraBjoerner07,ReynoldsTinelliMoura14}.
These methods work well in the context of proving (i..e, showing
unsatisfiability), but they are of little help for finding models (i.e.,
showing satisfiability). Often, a single universal quantifier in one of the
axioms of a problem is enough to prevent the discovery of models.

In the past few years, techniques have been developed to finding models for
quantified formulas in SMT.
Ge and de Moura \cite{GeDeM-CAV-09} introduced a complete instantiation-based
procedure for formulas in the \relax{essentially uninterpreted} fragment.
This fragment is limited to universally quantified formulas where all
%ct occurrences of 
variables occur as direct subterms of uninterpreted
functions---e.g., $\forall x%\typ{\typeint} --- the type is not important, right?
.\;\, \con{f}( x )
\teq \con{g}( x ) + 5$.
% since all
% occurrences of $x$ occur beneath uninterpreted functions $\con{f}$ and
% $\con{g}$.
Other syntactic criteria extend
this fragment slightly, including cases when variables occur as arguments of
arithmetic predicates. Subsequently, Reynolds et al.\
\cite{ReyEtAl-1-RR-13,reynolds-et-al-2013} introduced techniques for finding finite
models for quantified
formulas over uninterpreted types and types having a fixed finite
interpretation. %, such as fixed-width bit vectors and enumerated datatypes.
These techniques can
find a model for a formula such as $\forall x,\, y : \tau.\;\, x \teq
y \vee \allowbreak \neg \con{f}( x ) \teq \con{f}( y )$, where $\tau$ is an uninterpreted type.
% where the uninterpreted type $\tau$ is
% interpreted as a finite set and $\con{f}$ as injective finite map.

Unfortunately, neither of these fragments can accommodate the vast majority of
quantified formulas that correspond to recursive function definitions: The
essentially uninterpreted fragment does not allow the argument of a
recursive function to be used deep inside a complex term on the right-hand side,
whereas the finite model finding techniques of Reynolds et al.\ are not
applicable for functions over infinite domains such as the integers or
algebraic datatypes. A simple example where both approaches fail is
\begin{equation}\label{eq:pii}
\forall n : {\typeint}.\;\, \lite\bigl(
n \leq 0,\allowbreak\; \con{p}( n ) \teq 1,\allowbreak\; \con{p}( n ) \teq 2 * \con{p}( n - 1 ) \bigr)
\end{equation}
This state of affairs is highly unsatisfactory, given the frequence of
recursive definitions in practice and the impending addition of a dedicated
command, \texttt{define-fun-rec}, to the SMT-LIB standard \cite{smtlib25}.

In this paper, we present a method for translating formulas involving recursice function
definitions into formulas where finite model finding techniques can be applied.
The recursive functions must meet a semantic criterion to be admissible
(Section~\ref{sec:prelim}). This criterion is met by terminating recursive
function definitions, but also by
\relax{productive} corecursive functions. It is, however, not met by inconsistent
definitions such as $\forall n : {\typeint}.\;\, \con{f}(n) \teq \con{f}(n) +
1$, %ct and it is possible to construct consistent examples that do not meet it.
as well as other example of consistent definition.

We define a translation for a class of
formulas involving admissible recursive function definitions
(Section~\ref{sec:encoding}). The main insight is that a
recursive definition $\forall x : \tau.\;\, \const{f}(x) \teq t$
can be translated to
$\forall a :
\fargtype{\tau}.\;\, \const{f}(\farg{\con{f}}(a)) \teq t[\concret(a)/x]$, where
$\fargtype{\tau}$ is an uninterpreted \relax{abstract} type and $\farg{\con{f}} :
\fargtype{\tau} \to \tau$ converts the abstract type to the concrete
type. The translation preserves satisfiability and, for admissible definitions,
unsatisfiability, and makes finite model finding possible in practice
for problems in this class.

Our empirical evaluation on benchmarks from the IsaPlanner proof planner~\cite{DBLP:conf/itp/JohanssonDB10}
and the Leon verifier~\cite{suter-et-al-2011} provides
evidence that this translation improves the effectiveness of the SMT solvers
\cvc and \ziii for finding counterexamples to verification conditions
(Section~\ref{sec:evaluation}). The approach is implemented as a preprocessor
in \cvc (Section~\ref{sec:front-end}). When invoked with a
command-line option, the solver assumes that functions introduced using the
\texttt{define-fun-rec} command are admissible and translates them accordingly.

%this option targets users who wish to determine the satisfiability of inputs
%that involving function definitions that are known to be consistent, whereas it
%does not target users who wish to check the consistency of a set of function
%definitions.

\section{Preliminaries}
\label{sec:prelim}

Our setting is a (monomorphic) many-sorted first-order logic
like the one defined by SMT-LIB \cite{smtlib25}.
A \emph{signature} $\Sigma$ consists of
a set $\stypes{\Sigma}$ of %ct type symbols
first-order types
%
\ct{What the rationale for using the letter $y$ in $\stypes{\Sigma}$?}
\jb{y as in t\textbf{y}pe. changed to `ty'}
(or sorts) and a set $\sfuns{\Sigma}$ of function symbols over these types.
We assume that signatures always include a Boolean type $\Bool$ and constants
$\ltrue, \lfalse : \Bool$ for truth and falsity,
an infix equality predicate ${\teq} : \tau \times \tau \to \Bool$
for each $\tau \in \stypes{\Sigma}$,
standard Boolean connectives ($\neg$, $\wedge$, $\vee$, etc.),
and an if--then--else function symbol
$\lite : \Bool \times \tau \times \tau \rightarrow \tau$
for each $\tau \in \stypes{\Sigma}$.
Formulas are terms of type $\Bool$.
We write $t\typ{\tau}$ to denote a metavariable ranging over terms of
type~$\tau$ and $\terms( t )$ to denote the set of subterms in $t$.
Given a term $u$, we write $u[\vec t/\vec x]$ to denote the result of replacing
all occurrences of $\vec x$ with $\vec t$ in $u$.

%We write $\functerms^\Sigma( t )$ to denote the set of $f$-applications in $t$ such that $f \in \sfundefs{\Sigma}$.

A \emph{$\Sigma$-interpretation $\I$} %is a mathematical structure that
maps each type $\tau \in \stypes{\Sigma}$ to a nonempty set $\tau^\I$,
the \emph{domain} of~$\tau$ in~$\I$,
and each function symbol $\con{f} : \tau_1 \times \cdots \times \tau_n \rightarrow \tau$ in
$\sfuns{\Sigma}$
to a total function $\con{f}^\I : \tau_1^\I \times \cdots \times \tau_n^\I \rightarrow \tau^\I$.
A \emph{theory} is a pair $T = (\Sigma, \Mo)$ where
$\Sigma$ is a signature and $\Mo$ is a class of $\Sigma$-interpretations,
the \emph{models} of $T$.
A $\Sigma$-formula $\varphi$ is
\emph{$T$-satisfiable}
if it is satisfied by some interpretation in $\Mo$;
otherwise, it is \emph{$T$-unsatisfiable}.
A formula $\varphi$ \emph{$T$-entails} $\psi$, written $\varphi \models_T \psi$,
if all interpretations in $\Mo$ that satisfy $\varphi$ also satisfy $\psi$.
Two formulas $\varphi$ and $\psi$ are \emph{$T$-equivalent} 
if each $T$-entails the other.
Given a signature $\Sigma$,
the \emph{theory of equality with uninterpreted functions} \euf
consists of the set of all $\Sigma$-interpretations.
We refer to the type and function symbols in this theory as \emph{uninterpreted}.
\ct{This is both ambiguous and insufficient.
Since this is SMT we should fix some background theory $T$,
then extend its signature with additional symbols and call \emph{those} uninterpreted.
}

In addition to standard quantified formulas $\forall \vec x.\; \varphi$,
we consider \emph{annotated quantified formulas} of the form
$\forallf{\const{f}} \vec x.\; \varphi$, where $\con{f} \in \sfuns{\Sigma}$ is
an uninterpreted function symbol, 
whose semantics is the same as standard quantified formulas.
Given $\con{f} : \tau_1 \times \cdots \times \tau_n \rightarrow \tau$,
an annotated
quantified formula $\forallf{\con{f}} \vec x.\; \varphi$ is a \emph{function definition}
(\,\emph{for $\con{f}$}\vthinspace) if $\vec x$ is a tuple of variables
$x_1 : \tau_1$, $\ldots,$ $x_n : \tau_n$
and $\varphi$ is a quantifier-free formula 
$T$-equivalent to $\con{f}( \vec x ) \teq t$ for some term $t$ of type $\tau$.
%\ct{Why can't $\varphi$ be existential instead of just quantifier free?} 
%I don't think it makes much sense to have any quantifiers within function bodies, 
%since they aren't operational, that's why I put quantifier-free. --ajr
We write $\exists
\vec x.\; \varphi$ as a shorthand for $\neg \forall \vec x.\; \neg \varphi$.

\begin{definition}\rm
A formula $\varphi$ is in \emph{definitional form with respect to}
$\{ \con{f}_1, \ldots, \con{f}_n \} \subseteq \sfuns{\Sigma}$ if it is of the
form
%
%\kern-\abovedisplayskip
%\kern+\abovedisplayshortskip
%
\[(\forallf{\con{f}_1} \vec x_1.\; \varphi_1) \wedge \cdots \wedge
(\forallf{\con{f}_n} \vec x_n.\; \varphi_n) \wedge \psi\]
%
where $\con{f}_1, \ldots, \con{f}_n$ are distinct function symbols,
%ct added
$\forallf{\con{f}_i} \vec x_i.\; \varphi_i$ is a function definition
for $i = 1, \ldots, n$,
%
\ct{I think we need more conditions here on how a symbol $\con{f}_i$ can occur in $\varphi_j$.}
\jb{do we? I'd think that the admissibility criterion below is enough.}
and $\psi$ contains no function definitions.
We call $\psi$ the \emph{conjecture} of $\varphi$.
%\ct{Don't we need additional restrictions on the $\varphi_i$'s here?
%(E.g., they are quantifier-free, or perhaps existential or containing only let binders.)}
% Now fixed above -ajr
\end{definition}

Given a signature $\Sigma$, we distinguish the subset of \emph{defined}
function symbols $\sfundefs{\Sigma} \subseteq \sfuns{\Sigma}$.
We consider $\Sigma$-formulas that are in definitional form with respect to
$\sfundefs{\Sigma}$.

\begin{definition}\rm
Given a set of function definitions 
$\DDD = \{ \forallf{\con{f}_1} \vec x.\; \varphi_1, \ldots, \forallf{\con{f}_n} \vec x.\; \varphi_n \}$, 
a ground formula $\psi$ 
%\ct{I suppose $\psi$ is meant to be ground.} yes --ajr
is \emph{closed under function expansion with respect to $\DDD$} if 
\[
 \psi \,\models_T\, \bigwedge\nolimits_{\,i=1}^{n} \{ \psi_i[ \vec t / \vec x ] \mid \con{f}_i( \vec t ) \in \terms( \psi ) \} .
\]
The set $\DDD$ is \emph{admissible} if for every $T$-satisfiable formula 
$\psi$ closed under function expansion with respect to $\DDD$,
the formula
$\psi \wedge \bigwedge \Delta$ is also $T$-satisfiable.
%\ct{I}
\end{definition}

Admissibility is a semantic criterion that must be satisfied for each function
definition before applying the translation described in
Section~\ref{sec:encoding}. It is interesting it connect it with the more
standard notion of \emph{well-founded} function definitions, often called
\emph{terminating} definitions in a slight abuse of terminology. In such
definitions, all recursive calls are decreasing with respect to a well-founded
relation $r$, which must be supplied by the user or inferred automatically
using a termination prover. This ensures that the function is uniquely defined
at all points.

First-order logic has built-in notion of computation or termination. To ensure
that a function specification is well-founded, it is sufficient to require that
it would terminate when seen as a functional program for \relax{some}
evaluation order. For example,
$\{\forallf{\con{f}} n : {\typeint}.\;\, \lite\bigl(
n \leq 0,\allowbreak\; \con{p}( n ) \teq 1,\allowbreak\; \con{p}( n ) \teq 2 * \con{p}( n - 1 ) \bigr)\}$
can be shown well-founded under an evaluation strategy that consides one of the
two $\lite$ branches, based on the result of evaluating the condition.
Logically, such dependencies can be captured by congruence rules. Krauss
develops these ideas systematically in the more general context of higher-order
logic \cite[Section 2]{krauss-2009-phd}.

Another interesting fragment is the class of \emph{productive} corecursive
functions. Corecursive functions are functions to a coalgebraic datatype.
These functions can call themselves forever, without their being inconsistent.
Productive corecursive functions are functions that progressively reveal parts
of their (potentially infinite)
output \cite{turner-1995,mcbride-productive}.
For example, given a type of infinite streams constructed by $\con{scons}$,
the definition
$\{\forallf{\const{e}} n.\;\, \const{e}(n) \teq \con{scons}(n,\; \const{e}(n + 1))\}$
falls within this fragment, since each call to $\const{e}$ produces one
constructor before entering the nested call. Like terminating recursion,
productive corecursion totally specify the functions it defines. The
following theorem connects these notion with admissibility.

\begin{theorem}
Let
$\DDD = \{ \forallf{\con{f}_1} \vec x.\; \varphi_1, \ldots, \forallf{\con{f}_n}
\vec x.\; \varphi_n \}
$ be a set of function definitions such that for every
$(\stypes{\Sigma},\, \sfuns{\Sigma} - \sfundefs{\Sigma})$-interpretations
$\I_0$, there exists a unique
$\Sigma$-interpretation $\I$ that extends $\I_0$
and for which $\I \models \DDD$.
Then the set\/ $\DDD$ is admissible.
\end{theorem}
\begin{proofsketch}
Let $\varphi$ be a $T$-satisfiable formula closed under function expansion with
respect to $\DDD$.

We must show that the formula
$\varphi \wedge \bigwedge \Delta$ is also $T$-satisfiable.

Let $\J$ be a model of $\varphi$.

Let $\I_0$ be the restriction of $\J$ to the function symbols in $\sfuns{\Sigma} -
\sfundefs{\Sigma}$. By hypothesis, there exists a $\Sigma$-interpretation
$\I$ such that $\I \models \Delta$.

We must show that $\I$ coincides with $\J$ at the points of the functions
$\con{f}_i$ that they care about:

I.e. $\I$ is also a model of $\varphi$.
And by assumoption $I \models \Delta$, hence

%We have
%$\varphi \,\models_T\, \bigwedge\nolimits_{\,i=1}^{n} \{ \varphi_i[ \vec t / \vec x ] \mid \con{f}_i( \vec t ) \in \terms( \varphi ) \}$.



\qed
\end{proofsketch}

\newpage

For example, if $T$ is the theory of integer arithmetic,
the set $\{ \forallf{\con{f}} \vec x:\typeint.\;\, \con{f}( x ) \teq 0 \}$ is admissible.
An admissible set can include definitions of nonterminating functions,
\ct{There is no notion of termination in FOL. We either define this properly or we just replace "definitions of nonterminating functions, e.g.," with "definitions like"}
\ajr{I agree. Jasmin, can you fix this?  We need to be careful in the same way when we talk about the "terminating" functions fragment we handle.}
\jb{Yes, I need to rework and expand this whole part. Today.}
e.g.,
$\{ \forallf{\con{f}} x : \typeint.\;\, \con{f}( x ) \teq \con{f}( x - 1 ) \}$ or even $\{ \forallf{\con{f}} x.\allowbreak\;\, \con{f}( x ) \teq \con{f}( x ) \}$ are admissible.
On the other hand, the set $\{ \forallf{\con{f}} x.\;\, \con{f}( x ) \teq \con{f}( x ) + 1 \}$ is not admissible,
since the formula $\ltrue$ is (trivially) closed under function expansion with respect to this set,
and there is no model of $T$ satisfying $\forallf{\con{f}} x.\;\, \con{f}( x ) \teq \con{f}( x ) + 1$.
Consider the set 
$\{ 
 \forallf{\con{f}} x.\;\, \con{f}( x ) \teq \con{f}( x ),\;
 \forallf{\con{g}} x.\;\, \lite\bigl( \con{f}( x ) \teq 5,\;
   \con{g}( x ) \teq \con{f}( x ),\,
   \con{g}( x ) \teq \con{g}( x ) + 1)
\}$.
While this set has a model where $\con f$ and $\con g$ are interpreted as the constant $5$, it is not admissible
since the formula $\con{f}( 0 ) \teq 4$ is closed under function expansion with respect to this set,
but there exists no interpretation satisfying both $\con{f}( 0 ) \teq 4$ and $\forallf{\con{g}} x.\;\, \lite( \con{f}( x ) \teq 5,\, \con{g}( x ) \teq \con{f}( x ),\, \con{g}( x ) \teq \con{g}( x ) + 1 )$.


\jb{TODO: Jasmin: Identify fragments: terminating recursive functions, etc.}

%Terminating function specifications are always admissible, but also some
%nonterminating
%An admissible function definition need not specify a terminating function, e.g.
%$\{ \forallf{\con{f}} x^\typeint.\;\, \con{f}( x ) \teq \con{f}( x - 1 ) \}$ or even $\{ \forallf{\con{f}} x.\;\, \con{f}( x ) \teq \con{f}( x ) \}$ are admissible.

\section{The Translation}
\label{sec:encoding}

%%% TYPESETTING: approximated, to get centering
\newcommand{\itemx}{\itemindent5em\item}

\begin{figure}[t]
\normalsize
\begin{enumerate}
%\begin{framed}
\itemx[\ ]
$\conv_0( t\typ{\tau},\, p )$ $=$
\\[-.8\baselineskip]
 \begin{itemize}
   \itemx[] $\mathsf{if}$ $\tau = \Bool$ and $t = \boolop(t_1,\ldots,t_n)$ $\mathsf{then}$
    \begin{itemize}
      \itemx[] $\mathsf{let}$ $( t'_i,\, \chi_i ) = \conv_0( t_i,\, \pol( \boolop,\, i,\, p ) )$ $\mathsf{for}$ $i = 1, \ldots, n$ $\mathsf{in}$%\kern5em$\mid$
      \itemx[] $\mathsf{let}$ $\chi = \chi_1 \wedge \cdots \wedge \chi_n$ $\mathsf{in}$
      \itemx[] $\mathsf{if}$ $p = \ppos$ $\mathsf{then}$
      \begin{itemize}
        \itemx[] \return \bigtuple{$\boolop(t'_1, \ldots, t'_n) ) \wedge \chi,\, \ltrue$}
      \end{itemize}
      \itemx[] $\mathsf{else}$ $\mathsf{if}$ $p = \pneg$ $\mathsf{then}$
      \begin{itemize}
        \itemx[] \return \bigtuple{$\boolop(t'_1, \ldots, t'_n) \vee \neg \chi,\, \ltrue$}
      \end{itemize}
      \itemx[] $\mathsf{else}$
      \begin{itemize}
        \itemx[] \return \bigtuple{$\boolop(t'_1, \ldots, t'_n),\, \chi$}
\\[-.8\baselineskip]
      \end{itemize}
    \end{itemize}
  \itemx[] $\mathsf{else}$ $\mathsf{if}$ $t = \forallf{\con{f}} \vec x.\;\, u$ $\mathsf{then}$
    \begin{itemize}
      \itemx[] $\mathsf{let}$ $( u',\, \chi ) = \conv_0( u,\, p )$ $\mathsf{in}$
      %\itemx[] $\mathsf{assert}( \chi = \ltrue )$;
      \itemx[] \return \bigtuple{$\forall a : \fargtype{\con{f}}.\; u' [ \vecfarg{\con{f}}( a ) / \vec x ],\, \ltrue$}
\\[-.8\baselineskip]
    \end{itemize}
  \itemx[] $\mathsf{else}$ $\mathsf{if}$ $t = \forall \vec x.\;\, u$ $\mathsf{then}$
    \begin{itemize}
      \itemx[] $\mathsf{let}$ $( u',\, \chi ) = \conv_0( u,\, p )$ $\mathsf{in}$
      \itemx[] \return \bigtuple{$\forall \vec x.\; u',\, \forall \vec x.\; \chi$}
\\[-.8\baselineskip]
    \end{itemize}
   \itemx[] $\mathsf{else}$
   \begin{itemize}
     \itemx[] \return \bigtuple{$t,\; \bigwedge\, \{ \exists a : \fargtype{\con{f}}.\; \vecfarg{\con{f}}( a ) \teq \vec t \mid \con{f}( \vec t ) \in \terms( t ),\, \con{f} \in \sfundefs{\Sigma} \}$}
   \end{itemize}
 \end{itemize}
\end{enumerate}
\begin{enumerate}
%\begin{framed}
\itemx[\ ]
$\conv( \varphi )$ $=$
\\[-.8\baselineskip]
 \begin{itemize}
   \itemx[] $\mathsf{let}$ $( \varphi',\, \_ ) = \conv_0( \varphi,\, \ppos )$ $\mathsf{in}$
   %\itemx[] $\mathsf{assert}( D = \emptyset )$;
   \itemx[] \return $\varphi'$
  \end{itemize}
\end{enumerate}
\caption{\,Definition of function $\conv$}
\label{fig:A}
\end{figure}

We fix a signature $\Sigma$ and a $\Sigma$-formula
$\varphi$ in definitional form with respect to $\sfundefs{\Sigma}$,
whose definitions are admissible.
%We may translate $\varphi$ into a equisatisfiable formula $\phi'$ for which known model-finding procedures~\cite{GeDeM-CAV-09, ReyEtAl-1-RR-13} are applicable.
This section presents a method for constructing an extended signature
$\extendsig{ \Sigma }$ and an $\extendsig{ \Sigma }$-formula $\varphi'$ such that
$\varphi'$ is satisfiable if and only if $\varphi$ is satisfiable---i.e.,
$\varphi$ and $\varphi'$ are \emph{equisatisfiable}.
The intuition behind this translation
is to use an uninterpreted type to abstract the set of
\relax{relevant} tuples for each recursive function $\con{f}$ and restrict the
quantification of the function definition for $\con{f}$ to a variable of this
type. Informally, the relevant tuples $\vec t$ of a function $\con{f}$ are the
ones for which the interpretation of $\con{f}( \vec t )$ is relevant to the
satisfiability of $\varphi$.

More precisely,
suppose our signature $\Sigma$ contains a set of defined function symbols $\sfundefs{\Sigma} \subseteq \sfuns{\Sigma}$.
For each $\con{f} : \tau_1 \times \cdots \times \tau_n \rightarrow \tau \in \sfundefs{\Sigma}$,
the extended signature $\extendsig{\Sigma}$ includes
\begin{itemize}
\item an uninterpreted \emph{abstract type} $\fargtype{\con{f}}$;
\item $n$ uninterpreted \emph{concretization functions} $\fargx{\con{f}}{1} : \fargtype{\con{f}} \rightarrow \tau_1$, \ldots, $\fargx{\con{f}}{n} : \fargtype{\con{f}} \rightarrow \tau_n$.
\end{itemize}
%The interpretation of uninterpreted type $\fargtype{\con{f}}$ will denote the elements (tuples) on which the function $\con{f}$ is applied.
%The role of the uninterpreted functions $\farg{\con{f}}^1$, $\ldots$, $\farg{\con{f}}^n$ will be discussed more in the following.

The function $\conv$ defined in Figure~\ref{fig:A} translates the $\Sigma$-formula
$\varphi$ into an $\extendsig{\Sigma}$-formula. It relies
on the auxiliary function $\conv_0$, which takes two arguments:\ the term $t$
to translate and a \relax{polarity}~$p$, which is either $\ppos$, $\pneg$, or
$\pnone$ (none). \vthinspace$\conv_0$ returns a pair $( t'\negvthinspace,\, \chi )$, where $t'$ is a term of
type $\tau$ and $\chi$ is an additional constraint.
This constraint is needed if the polarity is $\pnone$; otherwise, it is encoded
directly in $t'$ and $\chi$ is simply $\ltrue$.
In the auxiliary function $\conv_0$, the function $\pol(
\boolop, i, p )$ returns the polarity of the $i$\vvthinspace{th} argument of an
application of~$\boolop$ having polarity $p$, where $\boolop$ is an interpreted
predicate.


%The role of $D$ is to ensure that
%the (restricted) function definition for $\con{f}$ includes certain tuples in
%its domain, which we explain more in the following.

The translation alters $\varphi$ in two main ways. First, it restricts the
quantification on function definitions for $\con{f}$ to the corresponding
uninterpreted type $\fargtype{\con{f}}$ and inserts appropriate selectors
$\fargx{\con{f}}{i}$. Second, it augments $\varphi$ with additional existential
constraints
$\exists a : \fargtype{\con{f}}.\;\, (\vecfarg{\con{f}}( a ) \teq \vec t)$; these
ensure that the restricted definition for $\con{f}$ covers all relevant tuples
of terms, namely the ones for which an $\con{f}$ application exists and is
relevant to the satisfiability of $\varphi$.
%\jb{what does ``current branch of'' mean? can we drop it / rephrase it / vague
%it up?}

If $t$ is an application of a logical predicate $\boolop
\in \{{\neg}, {\wedge}, {\vee}, {\teq}, {\lite}\}$,
$\conv_0$ calls itself recursively on the arguments $t_i$ and polarity $\pol(
\boolop, i, p )$, where $\pol$ is defined as
\begin{equation*}
\pol( \boolop, i, p ) =
\begin{cases}
p & \text{if either $\boolop \in \{{\wedge}, {\vee}\}$ or $\boolop = \lite$ and $i \in \{2, 3\}$} \\[-\jot]
\pnegate p & \text{if $\boolop = {\neg}$} \\[-\jot]
\pnone & \text{otherwise}
\end{cases}
\end{equation*}
The negation $\pnegate p$ of a polarity $p$ is $\pneg$ if $p$ is $\ppos$, $\ppos$
if $p$ is $\pneg$, and $\pnone$ if $p$ is $\pnone$.

If $t$ is positive, $\conv_0$ adds the constraint $\chi$ derived from
the subterms as a conjunction. Dually, if $t$ is negative, it constructs a
disjunction with the negated constraint. It $t$ has no polarity, the
constraint $\chi$ is simply returned to the caller.

If $t$ is a function definition of a function in
$\sfundefs{\Sigma}$, $\conv_0$ constructs a quantified formula over a single variable
$a$ of type $\fargtype{\con{f}}$ and replaces all occurrences of $\vec x$ in
$t'_1$ with $\vecfarg{\con{f}}( a )$. Since function definitions
are a top-level conjunct, %by case analysis on the return values of $\conv$,
$\chi$ must be $\ltrue$.

If $t$ is an unannotated quantified formula, $\conv_0$ recursively calls itself
on the body with the same polarity. A quantifier is prefixed to the
quantified formula and constraint returned by the recursive call.

Otherwise, $t$ is either an application of an uninterpreted predicate or a term
of a type other than $\Bool$. The returned constraint is a conjunction of
formulas of the form $\exists a : {\fargtype{\con{f}}}.\;\, \vecfarg{\con{f}}(
a ) \teq \vec t$ for each subterm $\con{f}( \vec t )$ of $t$ such that $\con{f}
\in \sfundefs{\Sigma}$. Such constraints, when asserted positively, ensure that
the tuple of uninterpreted functions $\vecfarg{\con{f}}$ has $\vec t$
in its range.

%We demonstrate this translation with an example.

\begin{example}
\label{ex:translation}
Consider the combined signature of linear arithmetic and uninterpreted
functions $\Sigma = \Sigmalia \mathrel{\uplus} \Sigma_{\euf}$, where
%$\stypes{\Sigma_{\euf}} = \{ \typeint \}$ 
%\ct{shouldn't this be $\stypes{\Sigmalia} = \{ \typeint \}$?}
%and
% Something went wrong, let's just remove it --ajr
$\sfuns{\Sigma_{\euf}} = \{ \con{s} : { \typeint \rightarrow \typeint },\, \const{c} : { \typeint } \}$.
Let $\varphi$ be the $\Sigma$-formula
\begin{equation} \label{eq:ex-before}
\forallf{\con{s}} x : {\typeint}.\;\, \lite\bigl( x \leq 0,\; \con{s}(x) \teq 0,\;
  \con{s}( x ) \teq x + \con{s}( x - 1 ) \bigr) \wedge \con{s}( \con{c} ) > 100
\end{equation}
%
\jb{I think $x$ is a great name for a metavariable standing for a variable, but
why insist on using it for concrete variables of type int, when literature
normally uses $i, \ldots, n$ (and keeps $x$ for real numbers and such)?}
The definition of $\const{s}$ specifies that it returns the sum of the
positive integers up to $x$. The formula $\varphi$ is in definitional form with
respect to $\sfundefs{\Sigma}$ 
%\jb{correct? It said $\Sigma_u$, which was definitely wrong} 
and states that the sum of all
positive numbers up to $\const{c}$ is greater than $100$. This formula is
satisfiable with a model that interprets $\const{c}$ as $14$ or more.
Due to the universal quantifier,
current SMT techniques
%~\cite{GeDeM-CAV-09, ReyEtAl-1-RR-13,reynolds-et-al-2013}
%%% We described them in the intro. When I see references like that appear with
%%% no description, as a reader, I get all paranoid and wonder if it's the old
%%% stuff from the intro (Ge, Moura, Renoylds et al.) or if it's new stuff ---
%%% and I cannot remember numbers like [9,18,19] across sections or even
%%% paragraphs. --jb
are unable to find
a model for this formula. The signature $\extendsig{\Sigma}$ includes the type
$\fargtype{\con{s}}$ and the uninterpreted function $\farg{\con{s}}$ of type $\fargtype{\con{s}}
\rightarrow \typeint$. The result of $\conv( \varphi )$ 
is $\varphi'$ which (after simplification) is the $\extendsig{\Sigma}$-formula
%
\begin{equation} \label{eq:ex-after}
\!\begin{aligned}[c]
  & \phantom{{\wedge}\; }\bigl(
      \forall a : \fargtype{\con{s}}.\; \lite\bigl(
        \!\begin{aligned}[t]
         &  \farg{\con{s}}( a ) \leq 0,\;
          \con{s}(\farg{\con{s}}( a )) \teq 0,\;
\\[-\jot]
  & \con{s}(\farg{\con{s}}( a )) \teq \farg{\con{s}}( a ) + \con{s}( \farg{\con{s}}( a )-1 )
    \wedge \exists b : {\fargtype{\con{s}}}.\;\, \farg{\con{s}}( b ) \teq \farg{\con{s}}( a )-1 \bigr) \bigr)
\end{aligned}
\\[-\jot]
 & {\wedge}\; \bigl( \con{s}( \con{c} ) > 100 \wedge \exists a : {\fargtype{\con{s}}}.\;\, \farg{\con{s}}( a ) \teq \con{c} \bigr)
\end{aligned}
\end{equation}
%
The universal quantification in the resulting formula is over an uninterpreted
type $\fargtype{\con{s}}$, thus enabling the finite model finding
techniques by Reynolds et al.\ \cite{ReyEtAl-1-RR-13,reynolds-et-al-2013},
implemented in \cvc, to search for a finite interpretation for $\fargtype{\con{s}}$. 
Since all occurrences of the quantified variable $a$ in this formula are 
beneath applications of the uninterpreted function $\farg{\con{s}}$, 
the formula is in the essentially uninterpreted fragment,
for which Ge and de Moura \cite{GeDeM-CAV-09} provide 
a complete instantiation procedure, implemented in \ziii. 
Both
%%% Added "apparently". Or are we sure?  
% Yes, I'm planning to post the 2 versions of the benchmark on the evaluation page (when we add it) --ajr
\cvc and \ziii run indefinitely on formula~(\ref{eq:ex-before}), 
while they both produce a model for formula~(\ref{eq:ex-after}) 
within 100 milliseconds.\xend
\end{example}

The translation $\conv$ results in formulas whose models are different than those of $\varphi$.
%\ct{"Preserves models" means that it does not drop models, not that it adds models.}
One model $\I$ for formula~(\ref{eq:ex-after}) in the previous example interprets
$\fargtype{\con{s}}$ as a finite set of elements $\{ u_0, \ldots, u_{14} \}$,
$\farg{\con{s}}$ as a finite map $u_i \mapsto i$ for $i = 0, \ldots, 14$,
$\con{c}$ as $14$,
and $\con{s}$ as the (almost constant) function
%
%% TYPESETTING: \mathbin and to make it fit nicely
\begin{equation} \label{eq:approx-interp}
\lambda x : \typeint.\;\, \lite( x \mathbin{\teq} 0,\, 0,\,
  \lite( x \mathbin{\teq} 1,\, 1,\,
    \lite( x \mathbin{\teq} 2,\, 3,\,
      \lite(\ldots,\; \lite( x \mathbin{\teq} 13,\, 91,\, 105 )\negvthinspace \ldots ))))
\end{equation}
%
In other words, $\const{s}$ is interpreted as a function mapping $x$ to the sum
of all positive integers between $0$ and $x$ when $0 \leq x \leq 13$, and $105$
otherwise.
The interpretation $\I$, restricted to $\Sigma$, is {not} a model for the original formula~(\ref{eq:ex-before}),
since $\I$ wrongly interprets $\con{s}( x )$ as $105$ when $x < 0$ or $x > 14$.

However, under the assumption that the function definitions in
$\sfundefs{\Sigma}$ are admissible, %we claim that
$\conv(\varphi)$ is equisatisfiable with $\varphi$ for any input $\varphi$.
\ct{Must define "equisatisfiable".
What we mean here is a weak form of satisfiability, we could instead say that
$\conv(\varphi)$ is $T$-satisfiable iff $\varphi$ is $T$-satisfiable.
} 
The intuition is that the
interpretation of a term such as $\con{s}( -1 )$ in the previous example is not
relevant to the satisfiability of formula~(\ref{eq:ex-before}). Thus, a
satisfiable or unsatisfiable response from an SMT solver on input $\conv(
\varphi )$ implies the existence or nonexistence of a model for
$\varphi$. Moreover, information in models for $\conv( \varphi )$ contains
pertinent information regarding the models of $\varphi$. For example, the model
$\I$ for formula~(\ref{eq:ex-after}) described above interprets $\con{c}$ as $14$,
and there exists a model of formula~(\ref{eq:ex-before}) that also interprets $\con{c}$
as $14$. In general, there exists a model of $\varphi$ that
coincides with each model of $\conv( \varphi )$ on its interpretation of all
functions in $\sfuns{\Sigma} - \sfundefs{\Sigma}$, i.e., $\{
\con{s} \}$ in the example.

%%% @ANDY: I don't get the following comment --jb
%   @JASMIN : The point of this comment is that the user is not interested in the SMT solver inferring any new information regarding the interpretation of s,
%             since s is a "defined" function, the user already has an intended interpretation in their head of what s is (here, the sum of positive integers between 0...x).
%             Thus, it isn't a big deal that the SMT solver "approximates" the interpretation of s during a check, since we already know what s is.
%From a practical point of view, this is not an
%issue, because $s$ is the very function that was explicitly defined by the
%user, and hence already has an intended interpretation.

In the following, for a ground formula $\varphi$, 
we write $\absconstraints( \varphi )$ to denote the set of constraints 
that force our concretization functions to include the necessary elements in their range
for determining the satisfiability of $\varphi$ with respect to function definitions in our translation.
Formally, we define $\absconstraints( \varphi )$ as:
\[
\absconstraints( \varphi ) = \{ \exists a : {\fargtype{\con{f}}}. ( \vecfarg{\con{f}}( a ) \teq \vec t ) \mid \con{f}( \vec t ) \in \terms( \varphi ), \con{f} \in \sfundefs{\Sigma} \}
\]
The following lemma states the central invariant behind our conversion function $\conv$.

\begin{lemma}\label{lem:conv}
Let $\varphi$ be a formula not containing function definitions,
and let $\I$ be a $\extendsig{\Sigma}$-interpretation.
Then, $\I$ satisfies $\conv( \varphi )$ if and only if
$\I$ satisfies $L \cup \absconstraints( L )$, where $L$ is a set of ground $\Sigma$-literals that entail $\varphi$.
%There exists a set of ground $\Sigma$-literals $L$ such that $L$ entails $\varphi$, 
%and $\I$ satisfies $L \cup \absconstraints( L )$.
\end{lemma}

\begin{cor}\label{cor:conv}
If $\varphi$ is a formula not containing function definitions, then $\conv( \varphi )$ entails $\varphi$.
\end{cor}

\begin{theorem}\label{thm:equi}
If $\varphi$ is a\/ $\Sigma$-formula that is in definitional form with respect to\/
$\sfundefs{\Sigma}$
and the set of function definitions\/ $\DDD$ corresponding to functions in
$\sfundefs{\Sigma}$ is admissible, then\/ $\varphi$ and\/ $\conv( \varphi )$ are
equisatisfiable.
\end{theorem}
\begin{proofsketch}
First, we show that if $\varphi$ is satisfied by $\Sigma$-interpretation $\I$, then $\conv( \varphi )$ is satisfied by a $\extendsig{\Sigma}$-interpretation $\J$.
Let $\J$ be the $\extendsig{\Sigma}$-interpretation that interprets all types $\tau \in \stypes{\Sigma}$ as $\tau^\I$,
all functions $\con{f} \in \sfuns{\Sigma}$ as $\con{f}^\I$,
and for each function $\con{f}$ of type $\tau_1 \times \cdots \tau_n \rightarrow \tau$ in $\sfundefs{\Sigma}$,
interprets $\fargtype{\con{f}}$ as a tuple of values of type $\tau_1^\I \times \cdots \times \tau_n^\I$,
and each $\fargx{\con{f}}{i}$ as the $i^{th}$ projection on such tuples for each $i = 1, \ldots, n$.
Note that $\J$ satisfies \emph{every} constraint of the form $\exists a : {\fargtype{\con{f}}}. ( \vecfarg{\con{f}}( a ) \teq \vec t )$,
since by our construction of $\J$ there exists an $a$ such that $a^\J = \vec t^\J$.
%By case analysis it follows that $\conv_0$ maintains the invariant that
%if $\conv_0( t\typ{\Bool}, \ppos )$ returns $( {t'}, \chi )$,
%then $\I$ satisfies $t$ if and only if $\J$ satisfies $t'$.
Since $\J$ satisfies $\varphi$, it satisfies a set of ground literals $L$ that entail $\varphi$.
Thus, $\J$ satisfies $L \cup \absconstraints( L )$, and by Lemma~\ref{lem:conv} we conclude $\J$ satisfies $\conv( \varphi )$.

Second, we show that if $\conv( \varphi )$ is satisfied by a
$\extendsig{\Sigma}$-interpretation $\I$, then $\varphi$ is satisfied by
$\Sigma$-interpretation $\J$. Since $\varphi$ is in definitional form with
respect to the functions defined by $\DDD$, we know $\varphi$ is of the form
$\DDD \wedge \varphi_0$. 
%We argue that $\I$ satisfies a $\Sigma$-formula
%$\varphi'$ that is closed under function expansion with respect to $\DDD$, and
%where $\varphi'$ entails $\varphi_0$.
%To construct $\varphi'$, 
First, we define a sequence of $\Sigma$-literals sets $L_0 \subseteq L_1 \subseteq \ldots$
such that $\I$ satisfies $L_i \cup \absconstraints( L_i )$ for each $i = 0, 1, \ldots$.
Since $\I$ satisfies $\conv( \varphi_0 )$,
by Lemma~\ref{lem:conv}, 
$\I$ satisfies a set of literals $L \cup \absconstraints( L )$ where $L$ is a set of $\Sigma$-literals that entail $\varphi_0$.
Let $L_0 = L$.
For each $i \geq 0$,
let $\psi_i$ be the formula $\bigwedge \{ \conv( \varphi_{\con{f}}[ \vec t / \vec x ] ) \mid \con{f}( \vec t ) \in \terms( L_i ), f \in \sfundefs{\Sigma} \}$,
where the function definition of $\con{f}$ in $\DDD$ is $\forallf{f} \vec x. \varphi_{\con{f}}$.
Since $\I$ satisfies $\conv( \forallf{f} \vec x. \varphi_{\con{f}} )$ and $\absconstraints( L_i )$,
we know that $\I$ also satisfies $\psi_i$.
Thus by Lemma~\ref{lem:conv},
$\I$ satisfies a set of literals $L \cup \absconstraints( L )$ where $L$ is a set of $\Sigma$-literals that entail $\psi_i$.
Let $L_{i+1} = L_0 \cup L$.
Let $L_n$ be the limit of this sequence,
and let $\psi$ be the $\Sigma$-formula $\bigwedge L_n$.
To show $\psi$ is closed under function expansion with respect to $\DDD$,
first note that by construction $\psi$ entails $\psi_n$.
For any function $\con{f}$ and terms $\vec t$, since $\varphi_{\con{f}}[ \vec t / \vec x ]$ does not contain function definitions,
by Corollary~\ref{cor:conv},
$\conv( \varphi_{\con{f}}[ \vec t / \vec x ] )$ entails $\varphi_{\con{f}}[ \vec t / \vec x ]$.
Thus, $\psi$ entails $\{ \varphi_{\con{f}}[ \vec t / \vec x ] \mid \con{f}( \vec t ) \in \terms( \psi ), f \in \sfundefs{\Sigma} \}$,
which by definition implies that $\psi$ is closed under function expansion with respect to $\DDD$.
Furthermore, $\psi$ entails $\varphi_0$ since $L_0 \subseteq L_n$.
Since $\psi$ is a $T$-satisfiable formula that is closed under function expansion with respect to $\DDD$ and $\DDD$ is admissible, 
by definition there exists a $\Sigma$-interpretation $\J$ satisfying $\psi \wedge \DDD$, which entails $\DDD \wedge \varphi_0$,
which is $\varphi$.
\ajr{Sketchy referring to "limit" of sequence, if it can be infinite. TODO: clarify/restrict.}
\qed
\end{proofsketch}

The intuition of the above proof is as follows.
First, $\conv( \varphi )$ cannot be unsatisfiable when $\varphi$ is satisfiable
since any model of $\varphi$ can be extended in a straightforward way to satisfy $\conv( \varphi )$.
Second, if a model is found for $\conv( \varphi )$,
then the constraints of the form $\exists a : \fargtype{\con{f}}.\;\, (\vecfarg{\con{f}}( a ) \teq \vec t)$
occurring in $\conv( \varphi )$ ensure that this model also satisfies
a $\Sigma$-formula that is closed under function expansion that entails the conjecture of $\varphi$.
Hence when $\DDD$ is admissible, this implies the existence of a model for $\varphi$.
For clarity, we demonstrate the consequences of this theorem in the context of a concrete example.

\begin{example}
Let us revisit the translated formula~(\ref{eq:ex-after}) from
Example~\ref{ex:translation}. 
This formula is unsatisfiable only if
formula~(\ref{eq:ex-before}) is unsatisfiable since $\fargtype{f}$ can be
interpreted as $\typeint$, and $\farg{f}$ can be interpreted as the identity
function. Conversely, we claim formula~(\ref{eq:ex-after}) is satisfiable
only if formula~(\ref{eq:ex-before}) is satisfiable, noting that the set
$\{ \forallf{\con{s}} x.\;\, \varphi_\con{s} \}$ is admissible,
where $\varphi_\con{s}$ is the formula $\lite\bigl( x \leq 0, \con{s}(x) \teq 0, \con{s}( x ) \teq x + \con{s}( x-1 ) \bigr)$.
%\ct{
%You cannot possibly mean "if and only if" in the two sentences above.
%Once I show that (1) is unsat iff (2) is unsat, I do not need to argue that
%(1) is sat iff (2) is sat. That is immediate.
%}
% You're right, changed both to "only if" --ajr
%As stated
%in the proof of Theorem~\ref{thm:equi}, the reason is that any model of
%formula~(\ref{eq:ex-after}) must satisfy a formula that is closed under
%function expansion, hence implying that formula~(\ref{eq:ex-before}) has a
%model.
%The rightmost conjunct $\exists a : {\fargtype{\con{s}}}. (\farg{\con{s}}( a ) \teq \con{c})$ 
%ensures that if $\con{s}( \con{c} ) > 100$ is a constraint that 
%formula~(\ref{eq:ex-after}) satisfying $\con{s}( \con{c} ) > 100$ also
%satisfies $\varphi_{\con{s}}[\con{c}/x]$. 
%The nested existential
%$\exists b.\;\, \farg{\con{s}}( b ) \teq \farg{\con{s}}( a )-1$ ensures that
%a similar constraint is enforced recursively: when $\varphi_{\con{s}}[t/x]$ is used in part to evaluate $\con{s}( \con{c} )$,
%any model of $\varphi_{\con{s}}[t/x]$ must also satisfy $\varphi_{\con{s}}[t-1/x]$ when $t > 0$. 
It is easy to see that any interpretation $\I$ satisfying formula~(\ref{eq:ex-after}) satisfies $L_0 \cup \absconstraints( L_0 )$,
where $L_0 = \{ \con{s}( \con{c} ) > 100 \}$, 
where $\absconstraints( L_0 )$ contains the single constraint $\exists a : {\fargtype{\con{s}}}. (\farg{\con{s}}( a ) \teq \con{c})$.
%The latter ensures that $\I$ satisfies a formula that entails both $\con{s}( \con{c} ) > 100$ and $\varphi_{\con{s}}[\con{c}/x]$.
Since $\I$ also satisfies both the translated function definition for $\con{s}$ (e.g. the first conjunct of formula~(\ref{eq:ex-after})) 
and $\absconstraints( L_0 )$, it must also satisfy the formula $\psi_1$:
\[
\lite\bigl( \con{c} \leq 0,\; 
            \con{s}(\con{c}) \teq 0,\;
            \con{s}(\con{c}) \teq \con{c} + \con{s}( \con{c}-1 )
            \wedge \exists b : {\fargtype{\con{s}}}.\;\, (\farg{\con{s}}( b ) \teq \con{c}-1) \bigr) \bigr)
\]

The existential $\exists b : {\fargtype{\con{s}}}.\;\, (\farg{\con{s}}( b ) \teq \con{c}-1)$ above
ensures that whenever $\I$ satisfies the set $L_1 = L_0 \cup \{ \neg \con{c} \leq 0, \con{s}(\con{c}) \teq \con{c} + \con{s}( \con{c}-1 ) \}$,
$\I$ satisfies $\absconstraints( L_1 )$ as well.
Hence, by repeated applications of this reasoning, it follows that
a model of formula~(\ref{eq:ex-after}) that interprets $\con{c}$ as $n$ must also satisfy the formula $\psi$:
%
\begin{equation} \label{eq:fun-closure}
\begin{split}
& \con{s}( \con{c} ) > 100 \wedge %\displaystyle
  \bigwedge\nolimits_{\vthinspace i=0}^{\!n-1} \bigl( \neg (\con{c}-i \leq 0) \wedge \con{s}( \con{c}-i ) \teq (\con{c}-i) + \con{s}( (\con{c}-i)-1 ) \bigr) \\[-\jot]
{\wedge}\; & \con{c}-n \leq 0 \wedge \con{s}( \con{c}-n ) \teq 0
\end{split}
\end{equation}
%
This formula is closed under function expansion,
since it contains the $\con{s}$ applications corresponding to
$\con{s}( \con{c}-i )$ for $i = 0, \ldots, n$. The formula also
entails $\varphi_\con{s}[\con{c}-i/x]$ for $i = 0, \ldots, n$.
Since $\varphi_\con{s}$ is an admissible definition,
there must exist a $\Sigma$-interpretation satisfying $\psi \wedge \forallf{\con{s}} x.\;\, \varphi_\con{s}$
which entails formula~(\ref{eq:ex-before}).\xend
\end{example}

\section{Evaluation}
\label{sec:evaluation}

In this section, we evaluate both the overall impact of the encoding introduced
in the previous section and the performance of individual SMT techniques for
benchmarks in the encoding.
The experimental data is publicly available.%
\footnote{\url{http://lara.epfl.ch/~reynolds/SMT2015-recfun/}}

We gathered a set of 245 benchmarks from two sources, which we will refer to as
\isa and \leon. The first source consists of the 79
benchmarks from the IsaPlanner
suite~\cite{DBLP:conf/itp/JohanssonDB10} that do not contain higher-order
functions. The benchmarks have been used recently as challenge problems for a
variety of inductive theorem provers. These benchmarks heavily involve
recursively-defined functions, and are limited to the combined theory of uninterpreted
functions and algebraic datatypes. The second source consists of 166
benchmarks from the Leon repository,\footnote{%Available at
\url{https://github.com/epfl-lara/leon}} which were constructed from
verification conditions from simple Scala programs. These benchmarks also
heavily involve recursively-defined functions over algebraic datatypes, 
but cover a wide variety of theories, including bit vectors, arrays, and linear and
nonlinear arithmetic. Each benchmark is in definitional form with respect to a
set of terminating functions.
%
% in particular they each
%are a conjoined list of function definitions followed by a (negated)
%conjecture.
A majority of these benchmarks are unsatisfiable, although a
handful of benchmarks in the \leon set are satisfiable.

For each of these 245 benchmarks, we considered (up to) three randomly selected
mutated forms of its conjecture $\psi$. In particular, we considered unique
conjectures that are obtained as a result of swapping a subterm of $\psi$ at
one position with another of the same type at another position.
Note that benchmarks created in this way have a high likelihood of having small
and easy-to-find countermodels. In total, we considered 213 mutated forms of
conjectures from \isa, and 427 mutated forms of conjectures from \leon. We will
call these sets \isam and \leonm respectively.

In total, our benchmark set consisted of 885 benchmarks (640 mutants plus the
original 245). We considered these 885 benchmarks both before and after the
translation $\conv$ as described in Section~\ref{sec:encoding}. For example,
\isa contains 79 original benchmarks $\varphi$ and 79 translated benchmarks
$\conv(\varphi)$.

For solvers, we considered the SMT solver \ziii~\cite{de-moura-bjoerner-2008},
which runs both heuristic methods for quantifier instantiation~\cite{MouraBjoerner07},
as well as methods for finding models for quantified formulas~\cite{GeDeM-CAV-09}.
We also considered three configurations of \cvc~\cite{barrett-et-al-2011} which
we will refer to as \cvcd, \cvcf, and \cvci.
The default configuration \cvcd runs heuristic and conflict-based techniques for quantifier instantiation~\cite{ReynoldsTinelliMoura14},
but does not include techniques for finding models.
The configuration \cvcf runs heuristic instantiation and the finite model
finding procedure described in~\cite{ReyEtAl-1-RR-13,reynolds-et-al-2013}. The
last configuration \cvci incorporates techniques for automating inductive
reasoning in SMT~\cite{reynolds-kuncak-2015}.

\begin{figure}[t]
\normalsize
\centering
\begin{tabular}{l@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\,\,}}
  & \multicolumn{2}{c@{\kern1.5em}}{\phantom{0}\ziiib}     & \multicolumn{2}{c@{\kern1.5em}}{\phantom{0}\cvcd}     & \multicolumn{2}{c@{\kern1.5em}}{\phantom{0}\cvcf}     & \multicolumn{2}{c@{\,\,}}{\phantom{0}\cvci}
\\%[-1pt]
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
\\
\midrule
\isa & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0
\\
\leon  & 0 & 2 & 0 & 0 & 0 & {\win 9} & 0 & 0
\\
\isam & 0 & 35 & 0 & 0 & 0 & {\win 153} & 0 & 0
\\
\leonm  & 11  & 75 & 6 & 6 & 6 & {\win 169} & 6 & 6
\\[\jot]
Total & \phantom{0}11  & 112 & \phantom{00}6 & \phantom{00}6 & \phantom{00}6 & {\win 331} & \phantom{00}6 & \phantom{00}6
\end{tabular}
\caption{\,Number of \emph{sat} responses on benchmarks without and with translation with $\conv$}
\label{fig:sat}
\end{figure}

\begin{figure}[t]
\normalsize
\centering
\begin{tabular}{l@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\kern1.5em}r@{\kern0.375em}r@{\,\,}}
  & \multicolumn{2}{c@{\kern1.5em}}{\phantom{0}\ziiib}     & \multicolumn{2}{c@{\kern1.5em}}{\phantom{0}\cvcd}     & \multicolumn{2}{c@{\kern1.5em}}{\phantom{0}\cvcf}     & \multicolumn{2}{c@{\,\,}}{\phantom{0}\cvci}
\\%[-1pt]
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
  & \hfill $\varphi$ \hfill & $\conv(\varphi)$\!\!
\\
\midrule
\isa & 14  & 15 & 15  & 15 & 15  & 15 & {\win 61}  & 14
\\
\leon  & 73  & 78 & 80  & 80 & 80  & 76 & {\win 96}  & 78
\\
\isam & 17  & 18 & 18  & 18 & 18  & 18 & {\win 44}  & 17
\\
\leonm  & 83  & 98 & 103 & 98 & 104 & 95 & {\win 117} & 98
\\[\jot]
Total & 187 & 209 & 216 & 211 & 217 & 204 & {\win 318} & 217
\end{tabular}
\caption{\,Number of \emph{unsat} responses on benchmarks without and with translation with $\conv$}
\label{fig:unsat}
\end{figure}

The results are shown in Figures \ref{fig:sat} and \ref{fig:unsat}.
They are divided into benchmarks triggering \emph{unsat} and \emph{sat}
responses and further into benchmarks before and after the translation $\conv$.
The raw evaluation data reveals no cases in which a solver answered
\emph{unsat} on a benchmark $\varphi$ and \emph{sat} on its
corresponding benchmark $\conv( \varphi )$, or vice versa, 
thereby corroborating Theorem~\ref{thm:equi}.
\ct{?! \emph{Theorems} do not need corroboration! 
Maybe we should say "consistently with Theorem~\ref{thm:equi}"?}

Figure~\ref{fig:sat} shows that for untranslated benchmarks (the ``$\varphi$''
columns), the number of \emph{sat} responses is very low, across all
configurations. This confirms the shortcomings of existing SMT techniques for
finding counterexamples for benchmarks containing recursively-defined functions.
%
The translation $\conv$ (the ``$\conv(\varphi)$'' columns) has a major
impact. \cvcf finds 331 of the 885 benchmarks to be satisfiable,
including 9~benchmarks in the unmutated \leon benchmark set. The
performance of \ziiib for counterexamples also improves dramatically, as it
solves 112 satisfiable problems, including 10 that were unsolved by \cvcf.
%
We conclude that the translation $\conv$ enables SMT
solvers to find counterexamples for conjectures involving recursively-defined functions
whose definitions are admissible.
%Both \ziiib and \cvcf were able to find a
%large number of counterexamples after the translation, with the latter
%configuration finding significantly more instances (331 to 112).

In terms of number of \emph{unsat} responses, the configuration \cvci is the
clear winner, finding 318 total benchmarks to be unsatisfiable. Moreover, the
translation $\conv$ helps \ziii for \emph{unsat} responses as well, as we
see \ziii solves a total of 209 whereas it solves only 187 before the
translation.
%
This number is 2 fewer than \cvcd, which finds 211 benchmarks unsatisfiable. Thus, in
most cases the translation $\conv$ does not significantly degrade performance
for unsatisfiable benchmarks, and in some cases may actually aid the solver for
determining unsatisfiability. The exception here is \cvci, whose inductive
arguments are guided by the types of quantified variables.

\section{Front-End Support in \cvc}
\label{sec:front-end}

The translation $\conv$ significantly improves the effectiveness of known SMT
techniques for finding counterexamples for formulas involving recursive
function definitions.
For the convenience of end users, it
has been implemented in the latest development version of \cvc %~\cite{ReyEtAl-1-RR-13}
(version~1.5 prerelease).
Function definitions $\forallf{\con{f}} \vec x.\; \varphi$ can be written using the $\definefunreccmd$ command,
from the upcoming SMT-LIB 2.5 standard \cite{smtlib25}.
For example, formula~(\ref{eq:ex-before}) from Example~\ref{ex:translation}
can be specified as
%
\begin{quote}
\small
\begin{verbatim}
(define-fun-rec s ((n Int)) Int (ite (<= n 0) 0 (+ n (s (- n 1)))))
(declare-fun c () Int)
(assert (> (s c) 100))
(check-sat)
\end{verbatim}
\end{quote}
%
When reading this input,
\cvc adds the annotated quantified formula
$$\forallf{\con{s}} x.\;\, \con{s}( x ) \teq \lite\bigl( x \leq 0,\; 0,\; \con{s}( x-1 )\bigr)$$
to its list of assertions,
which after rewriting becomes
$$\forallf{\con{s}} x.\;\, \lite\bigl( x \leq 0,\; \con{s}( x ) \teq 0,\; \con{s}( x ) \teq \con{s}( x-1 ) \bigr)$$
If \cvc's finite model finding mode for recursive functions is enabled (using
the command-line option \texttt{--fmf-fun}), it will replace its list of known
assertions based on the conversion $\conv$ before checking for satisfiability.
%If the functions provided in the input are admissible,
%then a ``satisfiable" response from the solver implies that a model exists for the original formula.
Accordingly, the solver will output the approximation of the interpretation it
used for recursive function definitions. For our example, it will produce the following output:
%\ajr{prefer having the full output like this here?}
%\jb{I like it the way you did it now, but I took the freedom to reformat the output slightly
%(to avoid the small font---I generally try to avoid ad hoc font mixtures---and to show
%the nesting more clearly).}
%it may output the interpretation~(\ref{eq:approx-interp}) from Section~\ref{sec:encoding} for $s$.
%
\begin{quote}
\small
\begin{verbatim}
(model
  (define-fun s (($x1 Int)) Int 
     (ite (= $x1 14) 105 (ite (= $x1 13) 91 (ite (= $x1 12) 78 
        (ite (= $x1 11) 66 (ite (= $x1 10) 55 (ite (= $x1 4) 10 
           (ite (= $x1 9) 45 (ite (= $x1 8) 36 (ite (= $x1 7) 28 
              (ite (= $x1 6) 21 (ite (= $x1 3) 6 (ite (= $x1 5) 15 
                 (ite (= $x1 2) 3 (ite (= $x1 1) 1 0)))))))))))))))
  (define-fun c () Int 14)
)
\end{verbatim}
\end{quote}

The \texttt{--fmf-fun} option instructs \cvc to assume that the
functions provided by the user are admissible.
Admissibility must be checked separately \emph{by the user}---for example, using a
syntactic criterion or a termination prover.
If this criterion is not met, \cvc may answer \emph{sat} on
an unsatisfiable problem. For example, if we add the inconsistent definition
%
\begin{quote}
\small
\begin{verbatim}
(define-fun-rec h ((n Int)) Int (+ (h n) 1))
\end{verbatim}
\end{quote}
%
to the above problem, \cvc will still return ``satisfiable"
if \texttt{--fmf-fun} is specified.

%Usually not interested in showing logical consistency, there
%exist other tools that check e.g. termination.
%Thus, want SMT solver to check satisfiability the assumption that recursive
%functions are consistent (where this needs to be defined precisely).

\section{Related Work}

We described the most closely related work, by Ge and de Moura
\cite{GeDeM-CAV-09} and by Reynolds et al.\
\cite{ReyEtAl-1-RR-13,reynolds-et-al-2013}, in the text already.
Outside the world of SMT, model finding has been
studied many times. 

Some finite model finders are based on a reduction to Boolean satisfiability
(SAT). They translate the input problem to propositional logic and pass it to a
SAT solver. The translation is parameterized by upper or exact finite bounds on
the cardinalities of the atomic types. This procedure was pioneered by McCune
in the earlier versions of Mace (also capitalized MACE) \cite{mccune-1994}.
Other SAT-based finders are Paradox \cite{claessen-sorensson-2003}, FMDarwin
\cite{xxxx}, and iProver \cite{xxxx} for first-order logic with equality;
\ct{FMDarwin is not SAT-based although it is Mace-like.
Calling iProver SAT-based is a stretch since it is based 
on a natively first-order calculus even it uses an auxiliary SAT solver heavily.
}
Alloy Analyzer and its back-end Kodkod \cite{torlak-jackson-2007} for
first-order relational logic; and Refute \cite{weber-2008} and Nitpick
\cite{blanchette-nipkow-2010} for higher-order logic.

An alternative to translating the problem to propositional logic is to perform
an exhaustive model search directly on the original problem. Given fixed
cardinalities, the search space is represented in memory as multidimensional
arrays. The procedure tries different values in the function and predicate
table entries, checking each time if the problem is satisfied and backtracking
if necessary. This approach was pioneered by FINDER \cite{slaney-1994} and
SEM \cite{zhang-zhang-1995} and serves as the basis of many more model finders,
notably the Alloy Analyzer's precursor \cite{jackson-1996} and the later
versions of~Mace \cite{mccune-prover9-mace4}.

Most of the above tool cannot cope with algebraic datatypes or other infinite
types. Kuncak and Jackson \cite{kuncak-jackson-2005} presented an idiom for
encoding datatypes and recursive functions in Alloy, by approximating datatypes
by finite subterm-closed substructures. The approach produces sound (fragments
of) models for formulas in the \relax{existential--bounded-universal} fragment
(i.e., formulas whose prenex normal forms contain no unbounded universal
quantifiers ranging over datatypes). This idiom was further developed by Dunets
et al.\ \cite{dunets-et-al-2010}, who showed how to handle primitive recursion.
Their definedness guards play a similar role to the existential constraints
generated by the $\conv$ translations.

The higher-order model finder Nitpick for the Isabelle/HOL proof assistant uses
another variant of Kuncak and Jackson's approach inside a Kleene-style
three-valued logic, inspired by abstract interpretation. It was also the first
tool of its kind to corecursion and codatatypes
\cite{blanchette-2013-relational}. The three-valued logic approach extends each
approximated type with an unknown value, which is propagated by function
application. This approach works reasonably well in Nitpick, because it builds
on Kodkod's relational logic, but our initial experiments with \cvc convinced
us that it is more efficient to avoid unknown values by adding constraints.

The Leon system \cite{suter-et-al-2011} implements a procedure that can both
produces proofs and counterexamples for properties of terminating functions
written in a subset of Scala. Leon is based on an SMT solver. It avoids
quantifiers altogether by unfolding recursive definitions up to a certain
depth, which is increased iteratively as necessary.
\jb{Andy: Can you add some more here? You're the Leon pro! E.g. why/when do we think
that our approach might be better?}
\ct{About Leon, the reviewers and readers may wonder why we do not do the same, that is, just progressively unfold the recursive definitions until a model is found.
We should probably say something in this regard.
}

Model finding is concerned with satisfying arbitrary logical constraints. Some
tools are optimized to work with problems that correspond to total functional
programs. The QuickCheck tool for Haskell \cite{claessen-hughes-2000} is an early example, based
on random testing. Bounded exhaustive testing \cite{runciman-et-al-2008} and
narrowing \cite{lindblad-2008-testing} are other popular strategies. These tool
are often much faster than model finders, but they typically cannot cope with
underspecification and nonexecutable functions.

% others
%are Agsy for Agda \cite{xxx}, Quickcheck for Isabelle/HOL \cite{xxx}, and
% QuickChick for Coq \cite{xxx}.


%Unlike an SMT solver, Nitpick cannot rely on a built-in notion of
%a datatype; it axiomatizes finite subterm-closed substructures.

%\begin{verbatim}
%Nitpick
%  * nice: three-valued logic (e.g. local overflow)
%    * solving a different problem:
%      * no built-in notion, what's approximated is an idealized notion, no
%        injections $\concret$
%  * not so nice:
%    one abstract domain per type, not per function argument
%  * guards + one-domain per arg are a good combi, guards + one-single-domain is bad because of
%    odd schemes, give unsat example
%    [* show that it works also for example with weird recursion schemes]
%
%  * other features:
%    * inductive / coinductive predicates
%    * quotient types
%
%  * abstract interpretation
%
%Leon
%\end{verbatim}

\section{Conclusion}
\label{sec:conclusion}

We presented a translation scheme that makes more SMT problems amenable to
finite model findings in SMT. In conjunction with the finite model finding
techniques introduced by Reynolds et al.\
\cite{ReyEtAl-1-RR-13,reynolds-et-al-2013}, it makes it possible to
find models of quantified formulas over infinite types, such as integers
and algebraic datatypes.

In future work, it would be interesting to evaluate the approach against other
model finders, notably Leon \ct{?? Leon is a model finder? Alloy?} and Nitpick, and enrich the benchmark suite with
problems exercising \cvc's support for codatatypes
\cite{reynolds-blanchette-2015-codata}. We also plan to integrate \cvc as a
counterexample generator in proof assistants.
\ct{Further work could also include identifying simple and/or syntactic sufficient conditions for admissibility. }

{%\footnotesize
\def\ackname{Acknowledgment}
\paragraph{%\footnotesize
\ackname.}
We would like to thank Damien Busato-Gaston and Emmanouil Koukoutos for
providing the initial set of benchmarks used in the evaluation.
}



{
\bibliographystyle{abbrv}
\bibliography{bib}
}

\end{document}
