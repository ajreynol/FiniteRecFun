%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[runningheads,a4paper]{llncs}
\usepackage{times}
\usepackage{listings}
\usepackage{colonequals}
%\usepackage{mathpartir}
\usepackage{xspace}
\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{stmaryrd}
\usepackage{cite}
\usepackage{hyperref}
\usepackage{framed}

% http://mirror.switch.ch/ftp/mirror/tex/macros/latex/contrib/xcolor/xcolor.pdf
\usepackage{xcolor}

%\usepackage{amsthm}
\usepackage{amsmath}    % need for subequations
\usepackage{booktabs}
%\usepackage{float}
%\usepackage{fullpage}
%\floatstyle{ruled}
%\newfloat{alg}{ht}{loa}
%\floatname{alg}{Algorithm}

\usepackage{url}
\urldef{\mailsa}\path|firstname.lastname@epfl.ch|
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\newcommand{\con}[1]{\mathsf{#1}}

\newcommand{\cvc}{\textsc{cvc}{\small 4}\xspace}
\newcommand{\cvciii}{\textsc{cvc}{\small 3}\xspace}
\newcommand{\ziii}{\textsc{z}{\small 3}\xspace}
\newcommand{\teq}{\approx}
\newcommand{\cc}[1]{#1^*}
\newcommand{\terms}{\mathbf{T}}
%\newcommand{\functerms}{\mathbf{DFT}}
\newcommand{\M}{\mathcal{M}}
\def\AIF{\qtab\keyword{if}\ }
\def\THEN{\ \keyword{then}\ }
\def\AELSE{\untab\qtab\keyword{else}\ }
\def\FI{\untab}
\def\RETURN{\keyword{return}\ }
\def\ENDPROC{\untab}
\newcommand{\conv}{\mathcal{W}}

\newcommand{\ssorts}[1]{#1^\mathrm{s}}
\newcommand{\sfuns}[1]{#1^\mathrm{f}}
\newcommand{\sfundefs}[1]{#1^\mathrm{df}}
\newcommand{\sfunndefs}[1]{#1^\mathrm{nf}}
\newcommand{\sortint}{\mathrm{Int}}

\newcommand{\pnone}{\con{none}}
\newcommand{\ptrue}{\con{true}}
\newcommand{\pfalse}{\con{false}}
\newcommand{\pol}{\con{pol}}

%\newtheorem{remark}{Remark}

\newcommand{\Bool}{\con{Bool}}
\newcommand{\ltrue}{\top}
\newcommand{\lfalse}{\bot}
\newcommand{\lite}{\con{ite}}

\newcommand{\boolop}{\oplus}
\newcommand{\forallf}[1]{\forall_{#1}}
\newcommand{\fnull}{\emptyset}
\newcommand{\farg}[1]{a_{#1}}
\newcommand{\vecfarg}[1]{\vec{a}_{#1}}
\newcommand{\fargsort}[1]{\upsilon_{#1}}

\newcommand{\Sigmalia}{\Sigma_{LIA}}
\newcommand{\extendsig}[1]{\mathcal{E}( #1 )}

\newcommand{\rem}[1]{\textcolor{red}{[#1]}}
\newcommand{\ajr}[1]{\rem{#1 --ajr}}


\newcommand{\vthinspace}{\kern+0.083333em}
\newcommand{\typ}[1]{^{\vthinspace #1}}

\newcommand{\definefunreccmd}{\con{define}\text{-}\con{fun}\text{-}\con{rec}}
\newcommand{\definefunsreccmd}{\con{define}\text{-}\con{funs}\text{-}\con{rec}}

%\input{scalalistings}
%\input{smtlib2listings}
\usepackage{program}

\begin{document}

\title{Model Finding for Recursive Functions in SMT}

\author {Andrew Reynolds\inst{1} \and Jasmin Christian Blanchette\inst{2,3} \and Cesare Tinelli \inst{4}}
\authorrunning {A. Reynolds \and J. C. Blanchette \and C. Tinelli}
\institute{
\'Ecole Polytechnique F\'ed\'erale de Lausanne (EPFL), Switzerland
\and
Inria Nancy \& LORIA, Villers-l\`es-Nancy, France
\and
Max-Planck-Institut f\"ur Informatik, Saarbr\"ucken, Germany
\and
Department of Computer Science, University of Iowa, USA
}

\maketitle

\begin{abstract}
To do.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

  * why model finding?
  * but SMT solvers better at proving
    * a single universal quantifier in an axiom is enough to put it off track
      (``maybe unsat'')

  * quantifiers in recursive fun defs

  * intuitively, finite quantification suffices:
    * if we make sure all needed values are there
    * if well-founded (assumed!)

  * nasty example (not well-founded)
    * f x = f x + 1

  * how we do it

  * show that it works also for example with weird recursion schemes

  * corecursive functions???
    * productive


\ajr{Demand for recursive functions in SMT (new draft includes define-funs-rec).  Usually not interested in showing logical consistency, there exist other tools that check e.g. termination. 
Thus, want SMT solver to check satisfiability the assumption that recursive functions are consistent (where this needs to be defined precisely).
}

\paragraph{Contributions}

\ajr{(1) Encoding, (2) Evaluation, (3) Front-end support for define-funs-rec in \cvc}

\section{Related Work}

first-order model finders: SEM, MACE/Mace, Paradox, iProver
  either direct search or reduction to SAT

Alloy (and Alloy idiom by Kuncak \& Jackson), Kodkod

The model finder for KIV based on Alloy

Refute
  * unsound handling of datatypes

Nitpick
  * inductive / coinductive predicates
  * quotient types

Leon

in smt : z3, cvc4 (briefly, text in main section gives detail)

\section{Preliminaries}
\label{sec:prelim}

A \emph{signature} $\Sigma$ consists of 
a set $\ssorts{\Sigma}$ of type symbols and
a set $\sfuns{\Sigma}$ of function symbols.
We assume that signatures always include a Boolean type $\Bool$ and constants 
$\ltrue$ and $\lfalse$ of that type (respectively, for true and false), 
an (infix) equality predicate $\teq$ of type $\sigma \times \sigma$ for each $\sigma \in \ssorts{\Sigma}$,
and standard boolean connectives ($\neg$, $\wedge$, $\vee$, $\lite$, etc.).
%and a function $\lite$ of type $\Bool \times \sigma \times \sigma$ for each $\sigma \in \ssorts{\Sigma}$.
We will write $t\typ{\tau}$ to denote a term $t$ of type~$\tau$.

In this paper, we associate quantified formulas with the uninterpreted functions whose semantics they define.
We will write $\forallf{f} \vec x. \varphi$ to denote a quantified formula that is defines the semantics of uninterpreted function $f$.
For consistency, we consider only quantified formulas of this form, 
and allow $f$ to be a distinguished constant $\fnull$, 
denoting that the quantified formula does not define the semantics of an uninterpreted function.
When $f$ is not $\fnull$, we will refer to $\forallf{f} \vec x. \varphi$ as a \emph{function definition} (for $f$).
We will write $\forall \vec x. \varphi$ as shorthand for $\forallf{\fnull} \vec x. \varphi$,
and $\exists \vec x. \varphi$ as shorthand for $\neg \forall \vec x. \neg \varphi$.

\ajr{theories, models, equisatisfiable, etc.}


\begin{definition}
A formula $\varphi$ \emph{well-defined with respect to functions} $S$ if it is of the form:
\begin{eqnarray} \label{eq:wdf}
(\forallf{f_1} \vec x_1. \varphi_1) \wedge \ldots \wedge (\forallf{f_n} \vec x_n. \varphi_n) \wedge \psi
\end{eqnarray}
where $f_1, \ldots, f_n$ are distinct, 
$S = \{ f_1, \ldots, f_n \}$,
and $\psi$ contains no function definitions.
\end{definition}

Given a signature $\Sigma$, 
we will commonly parition its function symbols $\sfuns{\Sigma}$ into $\sfundefs{\Sigma} \mathrel{\uplus} \sfunndefs{\Sigma}$,
where $\sfundefs{\Sigma}$ is the set of \emph{defined} function symbols,
and $\sfunndefs{\Sigma}$ are the others,
and consider $\Sigma$-formulas that are well-defined with respect to functions $\sfundefs{\Sigma}$.

We write $\terms( t )$ to denote the set of subterms in $t$.
%We write $\functerms^\Sigma( t )$ to denote the set of $f$-applications in $t$ such that $f \in \sfundefs{\Sigma}$.

\section{Model Finding for Recursive Functions in SMT}
\label{sec:model-finding-rec-fun}

Recent techniques~\cite{GeDeM-CAV-09, ReyEtAl-1-RR-13} 
have focused on finding models for quantified formulas in SMT.
A instatiation-based procedure is shown in~\cite{GeDeM-CAV-09} to be complete for formulas in the \emph{essentially uninterpreted} fragment.
This fragment is limited to universally quantified formulas where all occurrences of variables occur as direct subchildren of uninterpreted functions.
For instance, the formula $\forall x\typ{\sortint}. f( x ) \teq g( x ) + 5$ 
is in the essentially uninterpreted fragment since all occurrences of $x$ occur beneath uninterpreted functions $f$ and $g$.
Other syntactic criteria are identified in this paper that extend this fragment slightly, including cases when variables occur as arguments of arithmetic predicates.
The techniques in~\cite{ReyEtAl-1-RR-13} can be used for finding finite models for quantified formulas over uninterpreted types as well as types having a 
fixed finite interpretation (such as fixed-width bitvectors, datatype enumerations, etc.).
For instance, 
finite model finding techniques can find a model for
the formula $\forall x\typ{\tau} y\typ{\tau} z\typ{\tau}. x \teq y \vee y \teq z \vee x \teq z$
where the uninterpreted type $\tau$ is interpreted as a set of (at most) two elements.

Unfortunately, these fragments do not coincide with the vast majority of quantified formulas that correspond to recursive function definitions.
In particular, the fragments in~\cite{GeDeM-CAV-09} are not applicable when the argument of a recursive function is used in various ways (e.g. within an arithmetic expression), 
while the fragment in~\cite{ReyEtAl-1-RR-13} is not applicable for functions over infinite domains such as the integers.
So, for instance, the quantified formula $\forall x\typ{\sortint}. \lite( p \leq 0, p( x ) \teq 0, p( x ) \teq 2 * p( x - 1 ) )$ 
is not in the essentially uninterpreted fragment (since $x$ occurs as a child of $-$),
nor does finite model finding apply (since $x$ is of type $\sortint$).

Here, we advocate an approach that translates formulas involving function definitions (such as the one mentioned in the previous paragraph)
into equisatisfiable formulas where the techniques~\cite{GeDeM-CAV-09, ReyEtAl-1-RR-13} are applicable.

\subsection{A Translation for Function Definitions}
\label{sec:encoding}

In the remainder of the section, we fix a signature $\Sigma$.
Say that $\Sigma$-formula $\varphi$ is well-defined with respect to functions $\sfundefs{\Sigma}$, 
and the definitions in $\sfundefs{\Sigma}$ are logically consistent.
We may translate $\varphi$ into a equisatisfiable formula $\psi$ for which known model-finding procedures~\cite{GeDeM-CAV-09, ReyEtAl-1-RR-13} are applicable.
In particular, this section presents a method for constructing an extended signature $\extendsig( \Sigma )$,
and a $\extendsig( \Sigma )$-formula $\psi$ such that $\varphi$ and $\psi$ are equisatisfiable.
The intuition behind this translation is use an uninterpreted type to abstract the set of \emph{relevant} tuples for each recursive function $f$,
and restrict the quantification of the function definition for $f$ to a variable of this type.
Informally, the relevant tuples $\vec t$ of a function $f$ are the ones for which the interpretation of $f( \vec t )$ is relevant to the satisfiability of $\varphi$.

\begin{figure}[t]
\begin{enumerate}
%\begin{framed}
\item[\ ] 
$\conv( \varphi )$ : 
 \begin{itemize}
   \item[] $\mathsf{let}$ $( \psi, D ) = \conv( \varphi, \ptrue )$;
   %\item[] $\mathsf{assert}( D = \emptyset )$;
   \item[] $\mathsf{return}$ $\psi$
  \end{itemize}
\end{enumerate}
\begin{enumerate}
%\begin{framed}
\item[\ ] 
$\conv_0( t\typ{\tau}, p )$ : 
 \begin{itemize}
   \item[] $\mathsf{if}$ $\tau \equiv \Bool$ and $t \equiv t_1 \boolop \ldots \boolop t_n$ :
    \begin{itemize}
      \item[] $\mathsf{let}$ $( r_i, D_i ) = \conv_0( t_i, \pol( \boolop, i, p ) )$ for $i = 1, \ldots, n$;
      \item[] $\mathsf{if}$ $p = \ptrue$
      \begin{itemize}
        \item[] $\mathsf{return}$ $( ( r_1 \boolop \ldots \boolop r_n ) \wedge D_1 \wedge \ldots \wedge D_n, \emptyset )$
      \end{itemize}
      \item[] $\mathsf{else}$ $\mathsf{if}$ $p = \pfalse$
      \begin{itemize}
        \item[] $\mathsf{return}$ $( ( r_1 \boolop \ldots \boolop r_n ) \vee \neg D_1 \vee \ldots \vee \neg D_n, \emptyset )$
      \end{itemize}
      \item[] $\mathsf{else}$
      \begin{itemize}
        \item[] $\mathsf{return}$ $( r_1 \boolop \ldots \boolop r_n, D_1 \cup \ldots \cup D_n )$
      \end{itemize}
    \end{itemize}
  \item[] $\mathsf{else}$ $\mathsf{if}$ $t \equiv \forallf{f} \vec x. t_1$
    \begin{itemize}
      \item[] $\mathsf{let} ( r_1, D_1 ) = \conv_0( t_1, p )$;
      \item[] $\mathsf{if}$ $f \equiv \fnull$
      \begin{itemize}
        \item[] $\mathsf{return}$ $( \forall \vec x. r_1, \forall \vec x. D_1 )$
      \end{itemize}
      \item[] else
      \begin{itemize}
        %\item[] $\mathsf{assert}( D_1 = \emptyset )$;
        \item[] $\mathsf{return}$ $( \forall y\typ{\fargsort{f}}. ( r_1 [ \vecfarg{f}( y ) / \vec x ] ), \emptyset )$
      \end{itemize}
    \end{itemize}
   \item[] $\mathsf{else}$
   \begin{itemize}
     \item[] $\mathsf{return}$ $( t, \{ \exists z\typ{\fargsort{f}}. ( \vecfarg{f}( z ) \teq \vec t ) \mid f( \vec t ) \in \terms( t ), f \in \sfundefs{\Sigma} \} )$
   \end{itemize}
 \end{itemize}
\end{enumerate}
\vspace{-2ex}
\caption{A translation procedure $\conv$ for a $\Sigma$-formula that is well-defined with respect to function definitions.
In the subprocedure $\conv_0$, the procedure $\pol( \boolop, i, p )$ returns the polarity of the $i^{th}$ child of a $\boolop$-application having polarity $p$,
where $\boolop$ is an (interpreted) predicate.
}
\label{fig:encoding}
\end{figure}

In more detail, 
say our signature $\Sigma$ contains a set of defined function symbols $\sfundefs{\Sigma} \subseteq \sfuns{\Sigma}$.
We extend the signature of $\Sigma$ to a signature $\extendsig{\Sigma}$ containing the following additional definitions.
For each $f \in \sfundefs{\Sigma}$ of type $\tau_1 \times \ldots \tau_n \rightarrow \tau$, 
the signature $\extendsig{\Sigma}$ includes:
\begin{enumerate}
\item[-] an uninterpreted type $\fargsort{f}$, and
\item[-] a vector of $n$ uninterpreted functions $\farg{f}^1$, $\ldots$, $\farg{f}^n$ of type $(\fargsort{f} \rightarrow \tau_1)$, $\ldots$, $(\fargsort{f} \rightarrow \tau_n)$.
\end{enumerate}
%The interpretation of uninterpreted sort $\fargsort{f}$ will denote the elements (tuples) on which the function $f$ is applied.
%The role of the uninterpreted functions $\farg{f}^1$, $\ldots$, $\farg{f}^n$ will be discussed more in the following.

Given the extended signature, we run the procedure $\conv$ in Figure~\ref{fig:encoding} on $\varphi$.
This calls the subprocedure $\conv_0$, which takes two arguments: the term $t$ to translate, and a \emph{polarity} $p$ (either $\ptrue$, $\pfalse$, or $\pnone$).
It returns a pair of the form $( r, D )$, where $r$ is a term of type $\tau$, and $D$ is a set of formulas.
%The role of $D$ is to ensure that the (restricted) function definition for $f$ includes certain tuples in its domain, which we explain more in the following.
At a high level, the translation modifies $\varphi$ in two ways.
First, it restricts the quantification on function definitions for $f$ to the corresponding uninterpreted type $\fargsort{f}$.
Second, it augments $\varphi$ with additional constraints of the form $\exists z\typ{\fargsort{f}}. ( \vecfarg{f}( z ) \teq \vec t )$
which ensure that this restriction for the defintion $f$ covers all relevant tuples of terms,
namely the ones for which an $f$-application exists and is relevant to the satisfiability of the current branch of $\varphi$.

In the case that $t$ is an application of (interpreted) predicate $\boolop$ (e.g. a boolean connective, or equality),
we recursively call $\conv$ on its subchildren $t_i$ and polarity $\pol( \boolop, i, p )$, where $\pol$ is defined as\footnote{The negation $\neg p$ of polarity $p$ is 
$\pfalse$ if $p$ is $\ptrue$,
$\ptrue$ if $p$ is $\pfalse$, and
$\pnone$ if $p$ is $\pnone$.}:
\begin{equation*}
\pol( \boolop, i, p ) = \begin{cases}
                         \pnone & \boolop \equiv \teq \text{ or } ( \boolop \equiv \lite \text{ and } i=0 ) \\
                         \neg p & \boolop \equiv \neg \\
                         p & \text{otherwise}
                         \end{cases}
\end{equation*}
If $t$ has positive polarity,
we construct a conjunction of the result of the recursive calls with formulas $D_1, \ldots, D_n$.
Similarly, if $t$ has negative polarity,
we construct a disjunction of the result of the recursive calls with the negation of formulas $D_1, \ldots, D_n$.
It $t$ has no polarity,
then we return the union of $D_1 \cup \ldots \cup D_n$.

In the case that $t$ is a quantified formula $\forallf{f} \vec x. t_1$, it recursively calls $\conv$ on its body with the same polarity.
In the case that $t$ is not a function definition, 
the resulting quantified formula is reconstructed with the term $r_1$ returned by the recursive call,
and a quantified prefix is appended to the formula $D_1$ returned by the recursive call.
In the case that $t$ is a function definition,
we instead construct a quantified formula over a single variable $y$ of type $\fargsort{f}$,
and replace all occurrences of $\vec x$ in $r_1$ with $\vecfarg{f}( y )$.
In this case, since function definitions are a top-level conjunct, by case analysis on the return values of $\conv$, we know that $D_1$ is empty.

We demonstrate this translation with an example.

\begin{example}
\label{ex:translation}
Consider the (combined) signature $\Sigma = \Sigmalia \cup \Sigma_u$,
where $\ssorts{\Sigma_u} = \{ \sortint \}$ and 
$\sfuns{\Sigma_u} = \{ s\typ{ \sortint \rightarrow \sortint }, c\typ{ \sortint } \}$.
Consider the $\Sigma$-formula $\varphi$:
\begin{eqnarray} \label{eq:ex-before}
\forall_{s} x\typ{\sortint}. ite( x \leq 0, s(x) \teq 0, s( x ) \teq x + s( x-1 ) ) \wedge s( c ) > 100
\end{eqnarray} 
Here, $s$ is a function that returns the sum of positive numbers between $0$ and its argument $x$.
The formula $\varphi$ is well-defined with respect to functions $\sfundefs{\Sigma_u}$,
and states that the sum of all positive numbers between $0$ and $c$ is greater than $100$.
This formula is satisfiable with a model that interprets $c$ as an integer greater than or equal to $14$.
Due to the universally quantified formula in the left disjunct,
current SMT techniques~\cite{GeDeM-CAV-09, ReyEtAl-1-RR-13} are unable to find a model for this formula.
The signature $\extendsig{\Sigma}$ includes the type $\fargsort{s}$,
and the uninterpreted function $\farg{s}$ of type $\fargsort{s} \rightarrow \sortint$.
The result of $\conv( \varphi, \ptrue )$ is the pair $( \psi, \emptyset )$, where after simplification, $\psi$ is the $\extendsig{\Sigma}$-formula:
\begin{eqnarray} \label{eq:ex-after}
\begin{split}
\forall y\typ{\fargsort{s}}. ite( & \farg{s}( y ) \leq 0,  \\
 & s(\farg{s}( y )) \teq 0, \\
 & s(\farg{s}( y )) \teq \farg{s}( y ) + s( \farg{s}( y )-1 ) ) \\
 & \wedge \exists z\typ{\fargsort{s}}. \farg{s}( z ) \teq \farg{s}( y )-1 )
\end{split}  
\wedge ( s( c ) > 100 \wedge \exists z\typ{\fargsort{s}}. \farg{s}( z ) \teq c )
\end{eqnarray} 
The universal quantification in the resulting formula is over an uninterpreted type $\fargsort{s}$, 
thus enabling finite model finding techniques~\cite{ReyEtAl-1-RR-13} to search for a finite interpretation for $\fargsort{s}$.
Moreover, all occurrences of $y$ in this formula are beneath applications of the uninterpreted function $\farg{s}$,
implying that the formula is in the essentially uninterpreted fragment of~\cite{GeDeM-CAV-09}, for which there exists a complete instantiation procedure.
We observe that both \cvc and \ziii run indefinitely on formula~(\ref{eq:ex-before}),
and both produce a model for formula~(\ref{eq:ex-after}) in $<0.1$ second.
$\square$
\end{example}

It is important to note that the translation $\conv$ does not preserve the models of $\varphi$.
One model $\M$ for formula~(\ref{eq:ex-after}) in the previous example interprets 
$\fargsort{s}$ as a finite set of elements $\{ u_0, \ldots, u_{14} \}$,
$\farg{s}$ as a finite map mapping containing $u_i \mapsto i$ for $i = 0, \ldots, 14$,
$c$ as $14$, 
and $s$ as the (almost constant) function:
\begin{eqnarray}
\lambda x\typ{Int}. \lite( x \teq 0, 0, \lite( x \teq 1, 1, \lite( x \teq 2, 3, \ldots, \lite( x \teq 13, 91, 105 ) \ldots )
\end{eqnarray}
In other words, $s$ is a function mapping $x$ to the sum of all positive integers between $0$ and $x$ when $0 \leq x \leq 13$,
and $105$ otherwise.
Notice that $\M$ is \emph{not} a model for the original formula~(\ref{eq:ex-before}),
since $\M$ interprets e.g. $s( -1 )$ and $s( 15 )$ as $105$.
However, under the assumption that function definitions in $\sfundefs{\Sigma}$ are logically consistent, 
we claim that $\conv(\varphi)$ is equisatisfiable to $\varphi$.
The intuition is that the interpretation of a term such as $s( -1 )$ is not relevant to the satisfiability of~(\ref{eq:ex-before}).
\ajr{add invariants, proofs}

\begin{theorem}
If $\varphi$ be a $\Sigma$-formula that is well-defined with respect to functions $\sfundefs{\Sigma}$,
and function definitions in $\sfundefs{\Sigma}$ are logically consistent,
then $\varphi$ and $\conv( \varphi )$ are equisatisfiable.
\end{theorem}

\section{Evaluation}
\label{sec:evaluation}

In this section, we evaluate both 
the overall impact of the encoding introduced in the previous section, and
the performance of individual SMT techniques for benchmarks in the encoding.

For benchmarks, we gathered a set of 245 benchmarks from two sources, which we will refer to as {\bf isa} and {\bf leon}.
The first ({\bf isa}) consists of the 79 benchmarks from the Isaplanner benchmark suite~\cite{DBLP:conf/itp/JohanssonDB10} that did not contain higher-order functions.
The benchmarks have been used recently as challenge problems for a variety of inductive theorem provers.
These benchmarks heavily involve recursive functions, and are limited to the combined theory of uninterpreted functions and inductive datatypes.
The second ({\bf leon}) consists of 166 benchmarks from the Leon repository~\footnote{Available at \url{https://github.com/epfl-lara/leon}.},
which were constructed from verification conditions from simple Scala programs.
These benchmarks also heavily involve recursive functions over inductive datatypes, 
and also cover a wide variety of theories, including bitvectors, arrays, and linear and non-linear arithmetic.
Each of the 245 benchmarks are of the form described in formula~(\ref{eq:wdf}) from Section~\ref{sec:prelim},
in particular they each are a conjoined list of function definitions followed by a (negated) conjecture.
A majority of these benchmarks are unsatisfiable, although a handful of the benchmarks in the {\bf leon} set are satisfiable.

For each of these 245 benchmarks, we considered (up to) three randomly selected mutated forms of its conjecture $\psi$.
In particular, we considered unique conjectures that are obtained as a result of swapping a subterm of $\psi$ at one position
with another of the same type at another position.
Note that benchmarks created in this way have a high likelihood of having small and easy-to-find counterexamples.
In total, we considered 213 mutated forms of conjectures from {\bf isa}, and 427 mutated forms of conjectures from {\bf leon}.
We will call these sets {\bf isa+m} and {\bf leon+m} respectively.

In total, our benchmark set consisted of 885 benchmarks (640 mutants plus the original 245).
We considered these 885 benchmarks both before and after the translation $\conv$ as described in Section~\ref{sec:encoding}.
We will denote the latter encoding using the suffix {\bf w}.
For instance {\bf isa+w}, contains 79 benchmarks that are the results of applying $\conv$ to each of the 79 benchmarks in {\bf isa}.

For solvers, we considered the SMT solver \ziii~\cite{de-moura-bjoerner-2008}, 
which runs both heuristic methods for quantifier instantiation~\cite{DBLP:conf/cade/MouraB07},
as well as methods for finding models for quantified formulas~\cite{GeDeM-CAV-09}.
We also considered three configurations of \cvc~\cite{barrett-et-al-2011} which we will refer to as {\bf cvc4}, {\bf cvc4+f} and {\bf cvc4+i}.
The default configuration {\bf cvc4} runs heuristic quantifier instantiation, 
but does not include techniques for finding models.
The configuration {\bf cvc4+f} runs heuristic instantiation and the finite model finding procedure described in~\cite{ReyEtAl-1-RR-13, reynolds-et-al-2013}.
The last configuration {\bf cvc4+i} incorporates techniques for automating inductive reasoning in SMT~\cite{reynolds-kuncak-2015}.
%All configurations of \cvc incorporate techniques for conflict-based instantiation~\cite{} ..?

\begin{figure}[t]
\centering
{
\begin{tabular}{|l|cc|cc|cc|cc|l|cc|cc|cc|cc|}
\hline                                                                
  & \multicolumn{2}{c|}{{\bf z3}}     & \multicolumn{2}{c|}{{\bf cvc4}}     & \multicolumn{2}{c|}{{\bf cvc4+f}}     & \multicolumn{2}{c|}{{\bf cvc4+i}}     & & \multicolumn{2}{c|}{{\bf z3}}     & \multicolumn{2}{c|}{{\bf cvc4}}     & \multicolumn{2}{c|}{{\bf cvc4+f}}     & \multicolumn{2}{c|}{{\bf cvc4+i}}     
\\                                                                    
  & u & s & u & s & u & s & u & s & & u & s & u & s & u & s & u & s 
\\                                                                    
\hline                                                                    
{\bf isa} & 14  & 0 & 15  & 0 & 15  & 0 & {\bf 61}  & 0 & {\bf isa+w} & 15  & 0 & 15  & 0 & 15  & 0 & 14  & 0
\\                                                                  
{\bf leon}  & 73  & 0 & 80  & 0 & 80  & 0 & {\bf 96}  & 0 & {\bf leon+w}  & 78  & 2 & 80  & 0 & 76  & {\bf 9} & 78  & 0
\\                                                                   
{\bf isa+m} & 17  & 0 & 18  & 0 & 18  & 0 & {\bf 44}  & 0 & {\bf isa+mw}  & 18  & 35  & 18  & 0 & 18  & {\bf 153} & 17  & 0
\\                                                                  
{\bf leon+m}  & 83  & 11  & 103 & 6 & 104 & 6 & {\bf 117} & 6 & {\bf leon+mw} & 98  & 75  & 98  & 6 & 95  & {\bf 169} & 98  & 6
\\                                                                  
\hline                                                             
{\bf total} & 187 & 11  & 216 & 6 & 217 & 6 & {\bf 318} & 6 & {\bf total} & 209 & 112 & 211 & 6 & 204 & {\bf 331} & 207 & 6
\\                                                                                            
\hline                                                                                            
\end{tabular}
\\
}
\caption{Number of unsat and sat responses for of all configurations on benchmarks 
before and after the translation $\conv$.}
\label{fig:results}
\end{figure}

The results are shown in Figure~\ref{fig:results}.
The results are divided into benchmarks before and after the translation $\conv$.
First, we note that in no cases did a configuration answer differently across the two encodings.
In other words, there were no cases in which \ziii or \cvc answered e.g. ``unsatisfiable" on a benchmark $\varphi$
and ``satisfiable" on its corresponding benchmark $\conv( \varphi )$, or vice versa.
This provides confirming evidence that the translation $\conv$ is \emph{sound},
as we did not find a case where $\conv( \varphi )$ was unsatisfiable when $\varphi$ was satisfiable.
It also provides confirming evidence that the translation is \emph{complete} for this set of benchmarks,
as we did not find a case where $\conv( \varphi )$ was satisfiable when $\varphi$ was unsatisfiable.
This is to be expected, since the functions in our benchmark sets are intended to be logically consistent.

Examining the first encoding in isolation (the first nine columns),
the number of satisfiable responses from all configurations is quite low.
In total, {\bf z3} manages to find only 11 benchmarks to be satisfiable,
whereas each configuration of \cvc only finds 6.
This confirms the shortcomings of existing SMT techniques for finding counterexamples for benchmarks containing recursive functions.
In terms of number of unsatisfiable responses,
the configuration {\bf cvc4+i} is the clear winner, finding 318 total benchmarks to be unsatisfiable.

Now, examining the second encoding (the latter nine columns), 
we see that using the translation $\conv$ drastically improves the ability of configurations for answering satisfiable.
In total, {\bf cvc4+f} finds 331 of the 885 benchmarks to be satisfiable, including 9 benchmarks in the original {\bf leon} benchmark set.
The performance of {\bf z3} for counterexamples also improves drastically, as it solves 112 satisfiable,
including 10 that were unsolved by {\bf cvc4+f}.
Moreover, the translation $\conv$ helps \ziii for unsatisfiable responses as well,
as we see \ziii solves a total of 209 whereas it solves only 187 before the translation.
This number is 2 fewer than {\bf cvc4}, which solves 211 unsatisfiable.
Thus, in most cases the translation $\conv$ does not seriously degrade performance for unsatisfiable benchmark,
and in some cases may actually aid the solver for determining unsatisfiability
\footnote{The exception here is {\bf cvc4+i}, which makes use of type information associated with quantified formulas for inductive arguments.}.

We conclude from this evaluation that the translation $\conv$ enables SMT solvers to find counterexamples 
for conjectures involving recursive functions whose definitions are logically consistent.
Both {\bf z3} and {\bf cvc4+f} were able to find a large number of counterexamples after the translation,
with the latter configuration finding significantly more instances (331 to 112).

\section{Front-End Support for Recursive Function Definitions}
\label{sec:front-end}

We have seen a satisfiability-preserving translation $\conv$ that significantly improves the effectiveness of known SMT techniques
for finding counterexamples for formulas involving recursive function definitions.
For convienience, the translation $\conv$ has been implemented in the latest development version of \cvc~\cite{ReyEtAl-1-RR-13}.
Function definitions $\forallf{f} \vec x. \varphi$ can be written in using the $\definefunreccmd$ command, 
proposed in the draft of SMT version 2.5~\cite{}.
For instance, the input from Example~\ref{ex:translation} could be encoded as:

\begin{verbatim}
(define-fun-rec s ((x Int)) Int (ite (<= x 0) 0 (s (- x 1))))
(assert (> (s x) 100))
(check-sat)
\end{verbatim}

When reading this input, 
\cvc adds the (annotated) quantified formula $\forallf{s} x. s( x ) \teq \lite( x \leq 0, 0, s( x-1 ) )$ to its list of assertions,
which after rewriting becomes $\forallf{s} x. \lite( x \leq 0, s( x ) \teq 0, s( x ) \teq s( x-1 ) )$.
If \cvc is in finite model finding mode for recursive functions is enabled (using the command line parameter ``--fmf-fun"),
then it will replace its list of known assertions based on the conversion $\conv$ before checking for satisfiability.

\section{Conclusion}
\label{sec:conclusion}

  * future work
    * (co)inductive predicates?
    * quotient types??

{%\footnotesize
\def\ackname{Acknowledgment}
\paragraph{%\footnotesize
\ackname.}
We would like to thank Damien Busato-Gaston and Emmanouil Koukoutos for providing the initial set of benchmarks used in the evaluation.
This research is partially supported by the Inria technological development
action \relax{Contrexemples Utilisables par Isabelle et Coq} (CUIC).

}



{
\bibliographystyle{abbrv}
\bibliography{main}
}

\end{document}
